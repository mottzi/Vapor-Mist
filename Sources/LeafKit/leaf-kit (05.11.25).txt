########################################################

### TXTZIP: 'leaf-kit' (40 files, 7193 lines) @ '/Users/berken/Desktop/dev/Vapor/Vapor-mottzi.de/.build/checkouts/leaf-kit'
### MESSAGE: Fix_build_error_with_NIO_2861_and_bump_minimum_Swi

### leaf-kit/Package.swift
### leaf-kit/README.md
### leaf-kit/Sources/LeafKit/Character+Identities.swift
### leaf-kit/Sources/LeafKit/LeafAST.swift
### leaf-kit/Sources/LeafKit/LeafConfiguration.swift
### leaf-kit/Sources/LeafKit/LeafError.swift
### leaf-kit/Sources/LeafKit/LeafRenderer.swift
### leaf-kit/Sources/LeafKit/String+HTMLEscape.swift
### leaf-kit/Sources/LeafKit/Docs.docc/index.md
### leaf-kit/Sources/LeafKit/LeafCache/DefaultLeafCache.swift
### leaf-kit/Sources/LeafKit/LeafCache/LeafCache.swift
### leaf-kit/Sources/LeafKit/LeafData/LeafData.swift
### leaf-kit/Sources/LeafKit/LeafData/LeafDataRepresentable.swift
### leaf-kit/Sources/LeafKit/LeafData/LeafDataStorage.swift
### leaf-kit/Sources/LeafKit/LeafLexer/LeafLexer.swift
### leaf-kit/Sources/LeafKit/LeafLexer/LeafParameterTypes.swift
### leaf-kit/Sources/LeafKit/LeafLexer/LeafRawTemplate.swift
### leaf-kit/Sources/LeafKit/LeafLexer/LeafToken.swift
### leaf-kit/Sources/LeafKit/LeafParser/LeafParameter.swift
### leaf-kit/Sources/LeafKit/LeafParser/LeafParser.swift
### leaf-kit/Sources/LeafKit/LeafSerialize/Dictionary+LeafData.swift
### leaf-kit/Sources/LeafKit/LeafSerialize/LeafContext.swift
### leaf-kit/Sources/LeafKit/LeafSerialize/LeafSerializer.swift
### leaf-kit/Sources/LeafKit/LeafSerialize/ParameterResolver.swift
### leaf-kit/Sources/LeafKit/LeafSource/LeafSource.swift
### leaf-kit/Sources/LeafKit/LeafSource/LeafSources.swift
### leaf-kit/Sources/LeafKit/LeafSource/NIOLeafFiles.swift
### leaf-kit/Sources/LeafKit/LeafSyntax/LeafSyntax.swift
### leaf-kit/Sources/LeafKit/LeafSyntax/LeafTag.swift
### leaf-kit/Tests/LeafKitTests/HTMLEscapeTests.swift
### leaf-kit/Tests/LeafKitTests/LeafErrorTests.swift
### leaf-kit/Tests/LeafKitTests/LeafKitTests.swift
### leaf-kit/Tests/LeafKitTests/LeafSerializerTests.swift
### leaf-kit/Tests/LeafKitTests/LeafTests.swift
### leaf-kit/Tests/LeafKitTests/TagTests.swift
### leaf-kit/Tests/LeafKitTests/TestHelpers.swift
### leaf-kit/Tests/LeafKitTests/GHTests/VaporLeaf.swift
### leaf-kit/Tests/LeafKitTests/GHTests/VaporLeafKit.swift
### leaf-kit/Tests/LeafKitTests/Templates/test.leaf
### leaf-kit/Tests/LeafKitTests/Templates/SubTemplates/test.leaf

########################################################

### File: leaf-kit/Package.swift ###
// swift-tools-version:6.0
import PackageDescription

let package = Package(
    name: "leaf-kit",
    platforms: [
        .macOS(.v10_15),
        .iOS(.v13),
        .tvOS(.v13),
        .watchOS(.v6),
    ],
    products: [
        .library(name: "LeafKit", targets: ["LeafKit"])
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-nio.git", from: "2.81.0"),
    ],
    targets: [
        .target(
            name: "LeafKit",
            dependencies: [
                .product(name: "NIO", package: "swift-nio"),
                .product(name: "_NIOFileSystem", package: "swift-nio"),
                .product(name: "NIOFoundationCompat", package: "swift-nio"),
            ],
            swiftSettings: swiftSettings
        ),
        .testTarget(
            name: "LeafKitTests",
            dependencies: [
                .target(name: "LeafKit"),
            ],
            exclude: [
                "Templates",
            ],
            swiftSettings: swiftSettings
        ),
    ]
)

var swiftSettings: [SwiftSetting] { [
    .enableUpcomingFeature("ExistentialAny"),
    .enableUpcomingFeature("InternalImportsByDefault"),
    .enableUpcomingFeature("MemberImportVisibility"),
    .enableUpcomingFeature("InferIsolatedConformances"),
    .enableUpcomingFeature("NonisolatedNonsendingByDefault"),
    .enableUpcomingFeature("ImmutableWeakCaptures"),
] }

### File: leaf-kit/README.md ###
<p align="center">
<img src="https://design.vapor.codes/images/vapor-leafkit.svg" height="96" alt="LeafKit">
<br>
<br>
<a href="https://docs.vapor.codes/4.0/"><img src="https://design.vapor.codes/images/readthedocs.svg" alt="Documentation"></a>
<a href="https://discord.gg/vapor"><img src="https://design.vapor.codes/images/discordchat.svg" alt="Team Chat"></a>
<a href="LICENSE"><img src="https://design.vapor.codes/images/mitlicense.svg" alt="MIT License"></a>
<a href="https://github.com/vapor/leaf-kit/actions/workflows/test.yml"><img src="https://img.shields.io/github/actions/workflow/status/vapor/leaf-kit/test.yml?event=push&style=plastic&logo=github&label=tests&logoColor=%23ccc" alt="Continuous Integration"></a>
<a href="https://codecov.io/github/vapor/leaf-kit"><img src="https://img.shields.io/codecov/c/github/vapor/leaf-kit?style=plastic&logo=codecov&label=codecov" alt="Code Coverage"></a>
<a href="https://swift.org"><img src="https://design.vapor.codes/images/swift60up.svg" alt="Swift 6.0+"></a>
</p>

<br>

Leaf is a templating language for generating dynamic content such as HTML using a simple syntax.

## Overview

LeafKit is the main templating language for Vapor.

For more details, check out the [docs](https://docs.vapor.codes/leaf/getting-started/).

### File: leaf-kit/Sources/LeafKit/Character+Identities.swift ###
/// Various helper identities for convenience
extension Character {

    // MARK: - LeafToken helpers

    var isValidInTagName: Bool {
        self.isLowercaseLetter || self.isUppercaseLetter
    }
    
    var isValidInParameter: Bool {
        self.isValidInTagName ||
        self.isValidOperator ||
        self.isValidInNumeric
    }

    var canStartNumeric: Bool {
        (.zero ... .nine) ~= self
    }

    var isValidInNumeric: Bool {
        self.canStartNumeric ||
        self == .underscore ||
        self == .binaryNotation ||
        self == .octalNotation ||
        self == .hexNotation ||
        self.isHexadecimal ||
        self == .period
    }

    var isValidOperator: Bool {
        switch self {
        case .plus,
             .minus,
             .star,
             .forwardSlash,
             .percent,
             .equals,
             .exclamation,
             .lessThan,
             .greaterThan,
             .ampersand,
             .vertical:
            true
        default:
            false
        }
    }
    
    // MARK: - General group-membership identities (Internal)
    
    var isHexadecimal: Bool {
        (.zero ... .nine).contains(self) ||
        (.A ... .F).contains(self) ||
        (.a ... .f).contains(self) ||
        self == .hexNotation
    }

    var isOctal: Bool {
        (.zero ... .seven).contains(self) || self == .octalNotation
    }

    var isBinary: Bool {
        self == .zero || self == .one || self == .binaryNotation
    }

    var isUppercaseLetter: Bool {
        (.A ... .Z).contains(self)
    }

    var isLowercaseLetter: Bool {
        (.a ... .z).contains(self)
    }
    
    // MARK: - General helpers

    static let newLine: Self = "\n"
    static let quote: Self = "\""
    static let octothorpe: Self = "#"
    static let leftParenthesis: Self = "("
    static let backSlash: Self = "\\"
    static let rightParenthesis: Self = ")"
    static let comma: Self = ","
    static let space: Self = " "
    static let colon: Self = ":"
    static let period: Self = "."
    static let A: Self = "A"
    static let F: Self = "F"
    static let Z: Self = "Z"
    static let a: Self = "a"
    static let f: Self = "f"
    static let z: Self = "z"

    static let zero: Self = "0"
    static let one: Self = "1"
    static let seven: Self = "7"
    static let nine: Self = "9"
    static let binaryNotation: Self = "b"
    static let octalNotation: Self = "o"
    static let hexNotation: Self = "x"

    static let plus: Self = "+"
    static let minus: Self = "-"
    static let star: Self = "*"
    static let forwardSlash: Self = "/"
    static let percent: Self = "%"
    static let equals: Self = "="
    static let exclamation: Self = "!"
    static let lessThan: Self = "<"
    static let greaterThan: Self = ">"
    static let ampersand: Self = "&"
    static let vertical: Self = "|"
    static let underscore: Self = "_"
}

### File: leaf-kit/Sources/LeafKit/LeafAST.swift ###
import NIOCore

/// `LeafAST` represents a "compiled," grammatically valid Leaf template (which may or may not be fully resolvable or erroring)
public struct LeafAST: Hashable, Sendable {
    // MARK: - Public
    
    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.name)
    }

    public static func == (lhs: LeafAST, rhs: LeafAST) -> Bool {
        lhs.name == rhs.name
    }

    // MARK: - Internal/Private Only
    let name: String

    init(name: String, ast: [Syntax]) {
        self.name = name
        self.ast = ast
        self.rawAST = nil
        self.flat = false

        self.updateRefs([:])
    }
    
    init(from: LeafAST, referencing externals: [String: LeafAST]) {
        self.name = from.name
        self.ast = from.ast
        self.rawAST = from.rawAST
        self.externalRefs = from.externalRefs
        self.unresolvedRefs = from.unresolvedRefs
        self.flat = from.flat

        self.updateRefs(externals)
    }

    private(set) var ast: [Syntax]
    private(set) var externalRefs = Set<String>()
    private(set) var unresolvedRefs = Set<String>()
    private(set) var flat: Bool
    
    // MARK: - Private Only
    
    private var rawAST: [Syntax]?

    mutating private func updateRefs(_ externals: [String: LeafAST]) {
        var firstRun = false

        if self.rawAST == nil, self.flat == false {
            self.rawAST = self.ast
            firstRun = true
        }
        self.unresolvedRefs.removeAll()
        var pos = self.ast.startIndex

        // inline provided externals
        while pos < self.ast.endIndex {
            // get desired externals for this Syntax - if none, continue
            let wantedExts = self.ast[pos].externals()
            if wantedExts.isEmpty {
                pos = self.ast.index(after: pos)
                continue
            }
            // see if we can provide any of them - if not, continue
            let providedExts = externals.filter { wantedExts.contains($0.key) }
            if providedExts.isEmpty {
                self.unresolvedRefs.formUnion(wantedExts)
                pos = self.ast.index(after: pos)
                continue
            }
            
            // replace the original Syntax with the results of inlining, potentially 1...n
            let replacementSyntax = self.ast[pos].inlineRefs(providedExts, [:])
            self.ast.replaceSubrange(pos...pos, with: replacementSyntax)
            // any returned new inlined syntaxes can't be further resolved at this point
            // but we need to add their unresolvable references to the global set
            var offset = replacementSyntax.startIndex
            while offset < replacementSyntax.endIndex {
                self.unresolvedRefs.formUnion(self.ast[pos].externals())
                offset = replacementSyntax.index(after: offset)
                pos = self.ast.index(after: pos)
            }
        }

        // compress raws
        pos = self.ast.startIndex
        while pos < self.ast.index(before: ast.endIndex) {
            if case .raw(var syntax) = self.ast[pos] {
                if case .raw(var add) = self.ast[self.ast.index(after: pos)] {
                    var buffer = ByteBufferAllocator().buffer(capacity: syntax.readableBytes + add.readableBytes)
                    buffer.writeBuffer(&syntax)
                    buffer.writeBuffer(&add)
                    self.ast[pos] = .raw(buffer)
                    self.ast.remove(at: self.ast.index(after: pos))
                } else {
                    pos = self.ast.index(after: pos)
                }
            } else {
                pos = self.ast.index(after: pos)
            }
        }

        self.flat = self.unresolvedRefs.isEmpty ? true : false
        if firstRun, self.flat {
            self.rawAST = nil
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafConfiguration.swift ###
public import Foundation // there is no syntax to allow importing only String.Encoding 
import NIOConcurrencyHelpers

/// General configuration of Leaf
/// - Sets the default View directory where templates will be looked for
/// - Guards setting the global tagIndicator (default `#`).
public struct LeafConfiguration: Sendable {
    /// Initialize Leaf with the default tagIndicator `#` and unfound imports throwing an exception
    /// - Parameter rootDirectory: Default directory where templates will be found
    public init(rootDirectory: String) {
        self.init(rootDirectory: rootDirectory, tagIndicator: .octothorpe, ignoreUnfoundImports: true)
    }
    
    /// Initialize Leaf with a specific tagIndicator
    /// - Parameter rootDirectory: Default directory where templates will be found
    /// - Parameter tagIndicator: Unique tagIndicator - may only be set once.
    public init(rootDirectory: String, tagIndicator: Character) {
        self.init(rootDirectory: rootDirectory, tagIndicator: tagIndicator, ignoreUnfoundImports: true)
    }
    
    /// Initialize Leaf with a specific tagIndicator and custom behaviour for unfound imports
    /// - Parameter rootDirectory: Default directory where templates will be found
    /// - Parameter tagIndicator: Unique tagIndicator - may only be set once.
    /// - Parameter ignoreUnfoundImports: Ignore unfound imports - may only be set once.
    public init(rootDirectory: String, tagIndicator: Character, ignoreUnfoundImports: Bool) {
        Self._dataLock.withLockVoid {
            if !Self.started {
                Self._tagIndicator = tagIndicator
                Self.started = true
            }
        }
        self._rootDirectory = rootDirectory
        self._ignoreUnfoundImports = ignoreUnfoundImports
    }
    
    public var rootDirectory: String {
        mutating get { accessed = true; return self._rootDirectory }
        set { _rootDirectory = newValue }
    }
    
    public var ignoreUnfoundImports: Bool {
        mutating get { accessed = true; return self._ignoreUnfoundImports }
        set { self._ignoreUnfoundImports = newValue }
    }

    public static var encoding: String.Encoding {
        get { Self._dataLock.withLock { Self._encoding } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._encoding = newValue } } }
    }
    
    public static var boolFormatter: (Bool) -> String {
        get { Self._dataLock.withLock { Self._boolFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._boolFormatter = newValue } } }
    }
    
    public static var intFormatter: (Int) -> String {
        get { Self._dataLock.withLock { Self._intFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._intFormatter = newValue } } }
    }
    
    public static var doubleFormatter: (Double) -> String {
        get { Self._dataLock.withLock { Self._doubleFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._doubleFormatter = newValue } } }
    }
    
    public static var nilFormatter: () -> String {
        get { Self._dataLock.withLock { Self._nilFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._nilFormatter = newValue } } }
    }

    /// Note: ``voidFormatter`` is never used by Leaf.
    public static var voidFormatter: () -> String {
        get { Self._dataLock.withLock { Self._voidFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._voidFormatter = newValue } } }
    }
    
    public static var stringFormatter: (String) -> String {
        get { Self._dataLock.withLock { Self._stringFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._stringFormatter = newValue } } }
    }
    
    public static var arrayFormatter: ([String]) -> String {
        get { Self._dataLock.withLock { Self._arrayFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._arrayFormatter = newValue } } }
    }
    
    public static var dictFormatter: ([String: String]) -> String {
        get { Self._dataLock.withLock { Self._dictFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._dictFormatter = newValue } } }
    }
    
    public static var dataFormatter: (Data) -> String? {
        get { Self._dataLock.withLock { Self._dataFormatter } }
        set { Self._dataLock.withLockVoid { if !Self.running { Self._dataFormatter = newValue } } }
    }

    // MARK: - Internal/Private Only
    static var tagIndicator: Character {
        Self._tagIndicator // The lock is expensive; because the value is write-once, it's safe (enough) to skip it here
    }

    var _rootDirectory: String {
        willSet { assert(!accessed, "Changing property after LeafConfiguration has been read has no effect") }
    }
    
    var _ignoreUnfoundImports: Bool {
        willSet { assert(!accessed, "Changing property after LeafConfiguration has been read has no effect") }
    }

    private static let _dataLock: NIOLock = .init()

    private nonisolated(unsafe) static var _tagIndicator: Character = .octothorpe
    private nonisolated(unsafe) static var _encoding: String.Encoding = .utf8
    private nonisolated(unsafe) static var _boolFormatter: (Bool) -> String = { $0.description }
    private nonisolated(unsafe) static var _intFormatter: (Int) -> String = { $0.description }
    private nonisolated(unsafe) static var _doubleFormatter: (Double) -> String = { $0.description }
    private nonisolated(unsafe) static var _nilFormatter: () -> String = { "" }
    private nonisolated(unsafe) static var _voidFormatter: () -> String = { "" }
    private nonisolated(unsafe) static var _stringFormatter: (String) -> String = { $0 }
    private nonisolated(unsafe) static var _arrayFormatter: ([String]) -> String =
        { "[\($0.map {"\"\($0)\""}.joined(separator: ", "))]" }
    private nonisolated(unsafe) static var _dictFormatter: ([String: String]) -> String =
        { "[\($0.sorted { $0.0 < $1.0 }.map { "\($0): \"\($1)\"" }.joined(separator: ", "))]" }
    private nonisolated(unsafe) static var _dataFormatter: (Data) -> String? =
        { String(data: $0, encoding: Self._encoding) }

    /// Convenience flag for global write-once
    private nonisolated(unsafe) static var started = false
    /// Calls to this accessor must be guarded by the data lock; this avoids having to take the lock twice when setting values.
    private static var running: Bool {
        assert(!Self.started, "LeafKit can only be configured prior to instantiating any LeafRenderer")
        return Self.started
    }
    
    /// Convenience flag for local lock-after-access
    private var accessed = false
}

### File: leaf-kit/Sources/LeafKit/LeafError.swift ###
/// ``LeafError`` reports errors during the template rendering process, wrapping more specific
/// errors if necessary during Lexing and Parsing stages.
public struct LeafError: Error {
    /// Possible cases of a LeafError.Reason, with applicable stored values where useful for the type
    public enum Reason: Sendable {
        // MARK: Errors related to loading raw templates
        /// Attempted to access a template blocked for security reasons
        case illegalAccess(String)
        
        // MARK: Errors related to LeafCache access
        /// Attempt to modify cache entries when caching is globally disabled
        case cachingDisabled
        /// Attempt to insert a cache entry when one exists and replacing is not set to true
        /// - Provide the template name update was attempted on
        case keyExists(String)
        /// Attempt to modify cache for a non-existant key
        /// - Provide template name
        /// - NOTE: NOT thrown when "reading" from cache - nil Optional returned then
        case noValueForKey(String)

        // MARK: Errors related to rendering a template
        /// Attempt to render a non-flat AST
        /// - Provide template name & array of unresolved references
        case unresolvedAST(String, [String])
        /// Attempt to render a non-existant template
        /// Provide template name
        case noTemplateExists(String)
        /// Attempt to render an AST with cyclical external references
        /// - Provide template name & ordered array of template names that causes the cycle path
        case cyclicalReference(String, [String])

        // MARK: Wrapped Errors related to Lexing or Parsing
        /// Errors due to malformed template syntax or grammar
        case lexerError(LexerError)
        
        // MARK: Errors lacking specificity
        /// Errors from protocol adherents that do not support newer features
        case unsupportedFeature(String)
        /// Errors only when no existing error reason is adequately clear
        case unknownError(String)
    }
    
    /// Source file name causing error
    public let file: String
    /// Source function causing error
    public let function: String
    /// Source file line causing error
    public let line: UInt
    /// Source file column causing error
    public let column: UInt
    /// The specific reason for the error
    public let reason: Reason

    /// Provide  a custom description of the `LeafError` based on type.
    ///
    /// - Where errors are caused by toolchain faults, will report the Swift source code location of the call
    /// - Where errors are from Lex or Parse errors, will report the template source location of the error
    var localizedDescription: String {
        let file = self.file.split(separator: "/").last
        let src = "\(file ?? "?").\(function):\(line)"

        return switch self.reason {
            case .illegalAccess(let message):
                "\(src) - \(message)"
            case .unknownError(let message):
                "\(src) - \(message)"
            case .unsupportedFeature(let feature):
                "\(src) - \(feature) is not implemented"
            case .cachingDisabled:
                "\(src) - Caching is globally disabled"
            case .keyExists(let key):
                "\(src) - Existing entry \(key); use insert with replace=true to overrride"
            case .noValueForKey(let key):
                "\(src) - No cache entry exists for \(key)"
            case .unresolvedAST(let key, let dependencies):
                "\(src) - Flat AST expected; \(key) has unresolved dependencies: \(dependencies)"
            case .noTemplateExists(let key):
                "\(src) - No template found for \(key)"
            case .cyclicalReference(let key, let chain):
                "\(src) - \(key) cyclically referenced in [\(chain.joined(separator: " -> "))]"
            case .lexerError(let e):
                "Lexing error - \(e.localizedDescription)"
        }
    }
    
    /// Create a `LeafError`.
    public init(
        _ reason: Reason,
        file: String = #fileID,
        function: String = #function,
        line: UInt = #line,
        column: UInt = #column
    ) {
        self.file = file
        self.function = function
        self.line = line
        self.column = column
        self.reason = reason
    }
}

/// ``LexerError`` reports errors during the lexing stage.
public struct LexerError: Error {
    // MARK: - Public
    
    public enum Reason: Sendable {
        // MARK: Errors occuring during Lexing
        /// A character not usable in parameters is present when Lexer is not expecting it
        case invalidParameterToken(Character)
        /// A string was opened but never terminated by end of file
        case unterminatedStringLiteral
        /// Use in place of fatalError to indicate extreme issue
        case unknownError(String)
    }
    
    /// Template source file line where error occured
    public let line: Int
    /// Template source column where error occured
    public let column: Int
    /// Name of template error occured in
    public let name: String
    /// Stated reason for error
    public let reason: Reason
    
    // MARK: - Internal Only
    
    /// State of tokens already processed by Lexer prior to error
    let lexed: [LeafToken]
    /// Flag to true if lexing error is something that may be recoverable during parsing;
    /// EG, `"#anhtmlanchor"` may lex as a tag name but fail to tokenize to tag because it isn't
    /// followed by a left paren. Parser may be able to recover by decaying it to `.raw`.
    let recoverable: Bool
    
    /// Create a `LexerError`
    /// - Parameters:
    ///   - reason: The specific reason for the error
    ///   - src: File being lexed
    ///   - lexed: `LeafTokens` already lexed prior to error
    ///   - recoverable: Flag to say whether the error can potentially be recovered during Parse
    init(
        _ reason: Reason,
        src: LeafRawTemplate,
        lexed: [LeafToken] = [],
        recoverable: Bool = false
    ) {
        self.line = src.line
        self.column = src.column
        self.reason = reason
        self.lexed = lexed
        self.name = src.name
        self.recoverable = recoverable
    }
    
    /// Convenience description of source file name, error reason, and location in file of error source
    var localizedDescription: String {
        "\"\(self.name)\": \(self.reason) - \(self.line):\(self.column)"
    }
}

### File: leaf-kit/Sources/LeafKit/LeafRenderer.swift ###
public import protocol NIOCore.EventLoop
public import class NIOCore.EventLoopFuture
public import struct NIOCore.ByteBuffer

// MARK: - `LeafRenderer` Summary

/// `LeafRenderer` implements the full Leaf language pipeline.
///
/// It must be configured before use with the appropriate `LeafConfiguration` and consituent
/// threadsafe protocol-implementating modules (an NIO `EventLoop`, `LeafCache`, `LeafSource`,
/// and potentially any number of custom `LeafTag` additions to the language).
///
/// Additional instances of LeafRenderer can then be created using these shared modules to allow
/// concurrent rendering, potentially with unique per-instance scoped data via `userInfo`.
public final class LeafRenderer {
    // MARK: - Public Only
    
    /// An initialized `LeafConfiguration` specificying default directory and tagIndicator
    public let configuration: LeafConfiguration
    /// A keyed dictionary of custom `LeafTags` to extend Leaf's basic functionality, registered
    /// with the names which will call them when rendering - eg `tags["tagName"]` can be used
    /// in a template as `#tagName(parameters)`
    public let tags: [String: any LeafTag]
    /// A thread-safe implementation of `LeafCache` protocol
    public let cache: any LeafCache
    /// A thread-safe implementation of `LeafSource` protocol
    public let sources: LeafSources
    /// The NIO `EventLoop` on which this instance of `LeafRenderer` will operate
    public let eventLoop: any EventLoop
    /// Any custom instance data to use (eg, in Vapor, the `Application` and/or `Request` data)
    public let userInfo: [AnyHashable: Any]

    /// Initial configuration of LeafRenderer.
    public init(
        configuration: LeafConfiguration,
        tags: [String: any LeafTag] = defaultTags,
        cache: any LeafCache = DefaultLeafCache(),
        sources: LeafSources,
        eventLoop: any EventLoop,
        userInfo: [AnyHashable: Any] = [:]
    ) {
        self.configuration = configuration
        self.tags = tags
        self.cache = cache
        self.sources = sources
        self.eventLoop = eventLoop
        self.userInfo = userInfo
    }
    
    /// The public interface to `LeafRenderer`
    /// - Parameter path: Name of the template to be used
    /// - Parameter context: Any unique context data for the template to use
    /// - Returns: Serialized result of using the template, or a failed future
    ///
    /// Interpretation of `path` is dependent on the implementation of `LeafSource` but is assumed to
    /// be relative to `LeafConfiguration.rootDirectory`.
    ///
    /// Where `LeafSource` is a file sytem based source, some assumptions should be made; `.leaf`
    /// extension should be inferred if none is provided- `"path/to/template"` corresponds to
    /// `"/.../ViewDirectory/path/to/template.leaf"`, while an explicit extension -
    /// `"file.svg"` would correspond to `"/.../ViewDirectory/file.svg"`
    public func render(path: String, context: [String: LeafData]) -> EventLoopFuture<ByteBuffer> {
        guard !path.isEmpty else {
            return self.eventLoop.makeFailedFuture(LeafError(.noTemplateExists("(no key provided)")))
        }

        // If a flat AST is cached and available, serialize and return
        if let flatAST = self.getFlatCachedHit(path),
           let buffer = try? self.serialize(flatAST, context: context)
        {
            return self.eventLoop.makeSucceededFuture(buffer)
        }
        
        // Otherwise operate using normal future-based full resolving behavior
        nonisolated(unsafe) let nself = self
        return self.cache.retrieve(documentName: path, on: self.eventLoop).flatMapThrowing { cached in
            guard let cached else {
                throw LeafError(.noValueForKey(path))
            }
            guard cached.flat else {
                throw LeafError(.unresolvedAST(path, Array(cached.unresolvedRefs)))
            }
            return try nself.serialize(cached, context: context)
        }.flatMapError { e in
            return nself.fetch(template: path).flatMapThrowing { ast in
                guard let ast else {
                    throw LeafError(.noTemplateExists(path))
                }
                guard ast.flat else {
                    throw LeafError(.unresolvedAST(path, Array(ast.unresolvedRefs)))
                }
                return try nself.serialize(ast, context: context)
            }
        }
    }
    
    // MARK: - Private Only
    
    /// Given a `LeafAST` and context data, serialize the AST with provided data into a final render
    private func serialize(_ doc: LeafAST, context: [String: LeafData]) throws -> ByteBuffer {
        guard doc.flat else {
            throw LeafError(.unresolvedAST(doc.name, Array(doc.unresolvedRefs)))
        }

        var serializer = LeafSerializer(
            ast: doc.ast,
            tags: self.tags,
            userInfo: self.userInfo,
            ignoreUnfoundImports: self.configuration._ignoreUnfoundImports
        )
        return try serializer.serialize(context: context)
    }

    // MARK: `expand()` obviated

    /// Get a `LeafAST` from the configured `LeafCache` or read the raw template if none is cached
    ///
    /// - If the AST can't be found (either from cache or reading) return nil
    /// - If found or read and flat, return complete AST.
    /// - If found or read and non-flat, attempt to resolve recursively via `resolve()`
    ///
    /// Recursive calls to `fetch()` from `resolve()` must provide the chain of extended
    /// templates to prevent cyclical errors
    private func fetch(template: String, chain: [String] = []) -> EventLoopFuture<LeafAST?> {
        nonisolated(unsafe) let nself = self

        return self.cache.retrieve(documentName: template, on: self.eventLoop).flatMap { cached in
            guard let cached else {
                return nself.read(name: template, escape: true).flatMap { ast in
                    guard let ast else {
                        return nself.eventLoop.makeSucceededFuture(nil)
                    }
                    return nself.resolve(ast: ast, chain: chain).map { $0 }
                }
            }
            guard !cached.flat else {
                return nself.eventLoop.makeSucceededFuture(cached)
            }
            return nself.resolve(ast: cached, chain: chain).map { $0 }
        }
    }

    /// Attempt to resolve a `LeafAST`
    ///
    /// - If flat, cache and return
    /// - If there are extensions, ensure that (if we've been called from a chain of extensions) no cyclical
    ///   references to a previously extended template would occur as a result
    /// - Recursively `fetch()` any extended template references and build a new `LeafAST`
    private func resolve(ast: LeafAST, chain: [String]) -> EventLoopFuture<LeafAST> {
        // if the ast is already flat, cache it immediately and return
        guard !ast.flat else {
            return self.cache.insert(ast, on: self.eventLoop, replace: true)
        }

        var chain = chain
        chain.append(ast.name)

        let intersect = ast.unresolvedRefs.intersection(Set<String>(chain))
        guard intersect.count == 0 else {
            let badRef = intersect.first ?? ""
            chain.append(badRef)
            return self.eventLoop.makeFailedFuture(LeafError(.cyclicalReference(badRef, chain)))
        }

        let fetchRequests = ast.unresolvedRefs.map { self.fetch(template: $0, chain: chain) }

        nonisolated(unsafe) let nself = self
        let results = EventLoopFuture.whenAllComplete(fetchRequests, on: self.eventLoop)

        return results.flatMap { [chain] results in
            var externals: [String: LeafAST] = [:]

            for result in results {
                // skip any unresolvable references
                switch result {
                case .success(let external):
                    guard let external else {
                        continue
                    }
                    externals[external.name] = external
                case .failure(let e):
                    return nself.eventLoop.makeFailedFuture(e)
                }
            }
            // create new AST with loaded references
            let new = LeafAST(from: ast, referencing: externals)
            // Check new AST's unresolved refs to see if extension introduced new refs
            if !new.unresolvedRefs.subtracting(ast.unresolvedRefs).isEmpty {
                // AST has new references - try to resolve again recursively
                return nself.resolve(ast: new, chain: chain)
            } else {
                // Cache extended AST & return - AST is either flat or unresolvable
                return nself.cache.insert(new, on: nself.eventLoop, replace: true)
            }
        }
    }
    
    /// Read in an individual `LeafAST`
    ///
    /// If the configured `LeafSource` can't read a file, future will fail - otherwise, a complete (but not
    /// necessarily flat) `LeafAST` will be returned.
    private func read(name: String, escape: Bool = false) -> EventLoopFuture<LeafAST?> {
        let raw: EventLoopFuture<(String, ByteBuffer)>
        do {
            raw = try self.sources.find(template: name, in: nil, on: self.eventLoop)
        } catch {
            return self.eventLoop.makeFailedFuture(error)
        }

        return raw.flatMapThrowing { raw -> LeafAST? in
            var raw = raw
            guard let template = raw.1.readString(length: raw.1.readableBytes) else {
                throw LeafError.init(.unknownError("File read failed"))
            }
            var lexer = LeafLexer(name: name, template: LeafRawTemplate(name: name, src: template))
            let tokens = try lexer.lex()
            var parser = LeafParser(name: name, tokens: tokens)
            let ast = try parser.parse()
            return LeafAST(name: name, ast: ast)
        }
    }
    
    private func getFlatCachedHit(_ path: String) -> LeafAST? {
        // If cache provides blocking load, try to get a flat AST immediately
        guard let blockingCache = self.cache as? any SynchronousLeafCache,
           let cached = try? blockingCache.retrieve(documentName: path),
           cached.flat
        else {
            return nil
        }
        return cached
    }
}

### File: leaf-kit/Sources/LeafKit/String+HTMLEscape.swift ###
import Foundation

extension String {
    /// Escapes HTML entities in a `String`.
    public func htmlEscaped() -> String {
        if #available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *) {
            self
                .replacing("&", with: "&amp;")
                .replacing("\"", with: "&quot;")
                .replacing("'", with: "&#39;")
                .replacing("<", with: "&lt;")
                .replacing(">", with: "&gt;")
        } else {
            self
                .replacingOccurrences(of: "&", with: "&amp;")
                .replacingOccurrences(of: "\"", with: "&quot;")
                .replacingOccurrences(of: "'", with: "&#39;")
                .replacingOccurrences(of: "<", with: "&lt;")
                .replacingOccurrences(of: ">", with: "&gt;")
        }
    }
}

### File: leaf-kit/Sources/LeafKit/Docs.docc/index.md ###
# ``LeafKit``

Leaf is a templating language for generating dynamic content such as HTML using a simple syntax.

## Overview

LeafKit is the main templating language for Vapor.

For more details, check out the [docs](https://docs.vapor.codes/leaf/getting-started/).
### File: leaf-kit/Sources/LeafKit/LeafCache/DefaultLeafCache.swift ###
public import protocol NIOCore.EventLoop
public import class NIOCore.EventLoopFuture
import NIOConcurrencyHelpers

public final class DefaultLeafCache: SynchronousLeafCache {
    // MARK: - Public - `LeafCache` Protocol Conformance
    
    /// Global setting for enabling or disabling the cache
    public var isEnabled: Bool = true
    /// Current count of cached documents
    public var count: Int {
        self.lock.withLock { self.cache.count }
    }

    /// Initializer
    public init() {
        self.lock = .init()
        self.cache = [:]
    }

    /// - Parameters:
    ///   - document: The `LeafAST` to store
    ///   - loop: `EventLoop` to return futures on
    ///   - replace: If a document with the same name is already cached, whether to replace or not.
    /// - Returns: The document provided as an identity return
    public func insert(
        _ document: LeafAST,
        on loop: any EventLoop,
        replace: Bool = false
    ) -> EventLoopFuture<LeafAST> {
        // future fails if caching is enabled
        guard self.isEnabled else {
            return loop.makeSucceededFuture(document)
        }

        return self.lock.withLock {
            // return an error if replace is false and the document name is already in cache
            switch (self.cache.keys.contains(document.name), replace) {
                case (true, false):
                    return loop.makeFailedFuture(LeafError(.keyExists(document.name)))
                default:
                    self.cache[document.name] = document
            }
            return loop.makeSucceededFuture(document)
        }
    }
    
    /// - Parameters:
    ///   - documentName: Name of the `LeafAST`  to try to return
    ///   - loop: `EventLoop` to return futures on
    /// - Returns: `EventLoopFuture<LeafAST?>` holding the `LeafAST` or nil if no matching result
    public func retrieve(
        documentName: String,
        on loop: any EventLoop
    ) -> EventLoopFuture<LeafAST?> {
        guard self.isEnabled else {
            return loop.makeSucceededFuture(nil)
        }
        return self.lock.withLock {
            loop.makeSucceededFuture(self.cache[documentName])
        }
    }

    /// - Parameters:
    ///   - documentName: Name of the `LeafAST`  to try to purge from the cache
    ///   - loop: `EventLoop` to return futures on
    /// - Returns: `EventLoopFuture<Bool?>` - If no document exists, returns nil. If removed,
    ///     returns true. If cache can't remove because of dependencies (not yet possible), returns false.
    public func remove(
        _ documentName: String,
        on loop: any EventLoop
    ) -> EventLoopFuture<Bool?> {
        guard self.isEnabled else {
            return loop.makeFailedFuture(LeafError(.cachingDisabled))
        }

        return self.lock.withLock {
            guard self.cache[documentName] != nil else {
                return loop.makeSucceededFuture(nil)
            }
            self.cache[documentName] = nil
            return loop.makeSucceededFuture(true)
        }
    }
    
    // MARK: - Internal Only
    
    let lock: NIOLock
    var cache: [String: LeafAST]
    
    /// Blocking file load behavior
    func retrieve(documentName: String) throws -> LeafAST? {
        guard self.isEnabled else {
            throw LeafError(.cachingDisabled)
        }
        return try self.lock.withLock {
            guard let result = self.cache[documentName] else {
                throw LeafError(.noValueForKey(documentName))
            }
            return result
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafCache/LeafCache.swift ###
public import protocol NIOCore.EventLoop
public import class NIOCore.EventLoopFuture

/// `LeafCache` provides blind storage for compiled `LeafAST` objects.
///
/// The stored `LeafAST`s may or may not be fully renderable templates, and generally speaking no
/// attempts should be made inside a `LeafCache` adherent to make any changes to the stored document.
///
/// All definied access methods to a `LeafCache` adherent must guarantee `EventLoopFuture`-based
/// return values. For performance, an adherent may optionally provide additional, corresponding interfaces
/// where returns are direct values and not future-based by adhering to `SynchronousLeafCache` and
/// providing applicable option flags indicating which methods may be used. This should only used for
/// adherents where the cache store itself is not a bottleneck.
///
/// `LeafAST.name` is to be used in all cases as the key for retrieving cached documents.
public protocol LeafCache {
    /// Global setting for enabling or disabling the cache
    var isEnabled : Bool { get set }
    /// Current count of cached documents
    var count: Int { get }
    
    /// - Parameters:
    ///   - document: The `LeafAST` to store
    ///   - loop: `EventLoop` to return futures on
    ///   - replace: If a document with the same name is already cached, whether to replace or not.
    /// - Returns: The document provided as an identity return (or a failed future if it can't be inserted)
    func insert(
        _ document: LeafAST,
        on loop: any EventLoop,
        replace: Bool
    ) -> EventLoopFuture<LeafAST>
    
    /// - Parameters:
    ///   - documentName: Name of the `LeafAST`  to try to return
    ///   - loop: `EventLoop` to return futures on
    /// - Returns: `EventLoopFuture<LeafAST?>` holding the `LeafAST` or nil if no matching result
    func retrieve(
        documentName: String,
        on loop: any EventLoop
    ) -> EventLoopFuture<LeafAST?>

    /// - Parameters:
    ///   - documentName: Name of the `LeafAST`  to try to purge from the cache
    ///   - loop: `EventLoop` to return futures on
    /// - Returns: `EventLoopFuture<Bool?>` - If no document exists, returns nil. If removed,
    ///     returns true. If cache can't remove because of dependencies (not yet possible), returns false.
    func remove(
        _ documentName: String,
        on loop: any EventLoop
    ) -> EventLoopFuture<Bool?>
}

/// A `LeafCache` that provides certain blocking methods for non-future access to the cache
///
/// Adherents *MUST* be thread-safe and *SHOULD NOT* be blocking simply to avoid futures -
/// only adhere to this protocol if using futures is needless overhead
protocol SynchronousLeafCache: LeafCache {
    /// - Parameters:
    ///   - document: The `LeafAST` to store
    ///   - replace: If a document with the same name is already cached, whether to replace or not
    /// - Returns: The document provided as an identity return, or nil if it can't guarantee completion rapidly
    /// - Throws: `LeafError` .keyExists if replace is false and document already exists
    func insert(_ document: LeafAST, replace: Bool) throws -> LeafAST?
    
    /// - Parameter documentName: Name of the `LeafAST` to try to return
    /// - Returns: The requested `LeafAST` or nil if it can't guarantee completion rapidly
    /// - Throws: `LeafError` .noValueForKey if no such document is cached
    func retrieve(documentName: String) throws -> LeafAST?
    
    /// - Parameter documentName: Name of the `LeafAST`  to try to purge from the cache
    /// - Returns: `Bool?` If removed,  returns true. If cache can't remove because of dependencies
    ///      (not yet possible), returns false. Nil if it can't guarantee completion rapidly.
    /// - Throws: `LeafError` .noValueForKey if no such document is cached
    func remove(documentName: String) throws -> Bool?
}

extension SynchronousLeafCache {
    func insert(_ document: LeafAST, replace: Bool) throws -> LeafAST? { nil }
    func retrieve(documentName: String) throws -> LeafAST? { nil }
    func remove(documentName: String) throws -> Bool? { nil }
}

### File: leaf-kit/Sources/LeafKit/LeafData/LeafData.swift ###
public import struct Foundation.Data
import NIOCore

/// `LeafData` is a "pseudo-protocol" wrapping the physically storable Swift data types
/// Leaf can use directly
/// - `(Bool, Int, Double, String, Array, Dictionary, Data)` are the inherent root types
///     supported, all of which may also be representable as `Optional` values.
/// - `NaturalType` presents these cases plus `Void` as a case for functional `LeafSymbols`
/// - `nil` is creatable, but only within context of a root base type - eg, `.nil(.bool)` == `Bool?`
public struct LeafData:
    CustomStringConvertible,
    Equatable,
    ExpressibleByDictionaryLiteral,
    ExpressibleByStringLiteral,
    ExpressibleByIntegerLiteral,
    ExpressibleByBooleanLiteral,
    ExpressibleByArrayLiteral,
    ExpressibleByFloatLiteral,
    ExpressibleByNilLiteral,
    Sendable
{
    /// The concrete instantiable object types for a `LeafData`
    public enum NaturalType: String, CaseIterable, Hashable, Sendable {
        case bool
        case string
        case int
        case double
        case data
        case dictionary
        case array
        case void
    }

    /// The case-self identity
    public var celf: NaturalType {
        self.storage.concreteType
    }

    /// Returns `true` if the data is `nil` or `void`.
    public var isNil: Bool {
        self.storage.isNil
    }
    /// Returns `true` if the data can hold other data - we don't consider `Optional` for this purpose
    public var isCollection: Bool {
        [.array, .dictionary].contains(self.storage.concreteType)
    }

    /// Returns `true` if concrete object can be exactly or losslessly cast to a second type
    /// - EG: `.nil ` -> `.string("")`, `.int(1)` ->  `.double(1.0)`,
    ///      `.bool(true)` -> `.string("true")` are all one-way lossless conversions
    /// - This does not imply it's not possible to *coerce* data - handle with `coerce(to:)`
    ///   EG: `.string("")` -> `.nil`, `.string("1")` -> ` .bool(true)`
    public func isCastable(to type: LeafData.NaturalType) -> Bool {
        let conversion = _ConverterMap.symbols.get(self.storage.concreteType, type)!

        return conversion.is >= DataConvertible.castable
    }
    
    /// Returns `true` if concrete object is potentially directly coercible to a second type in some way
    /// - EG: `.array()` -> `.dictionary()` where array indices become keys
    ///       or `.int(1)` -> `.bool(true)`
    /// - This does *not* validate the data itself in coercion
    public func isCoercible(to type: LeafData.NaturalType) -> Bool {
        let conversion = _ConverterMap.symbols.get(self.storage.concreteType, type)!

        return conversion.is >= DataConvertible.coercible
    }
    
    // MARK: - Equatable Conformance
    public static func ==(lhs: LeafData, rhs: LeafData) -> Bool {
        // Strict compare of invariant stored values; considers nils equal
        if lhs.storage == rhs.storage {
            return true
        }
        // If either side is nil, false - storage == would have returned false
        if lhs.isNil || rhs.isNil {
            return false
        }
        // Fuzzy comparison by string casting
        guard lhs.isCastable(to: .string),
              rhs.isCastable(to: .string),
              let lhs = lhs.string, let rhs = rhs.string
        else {
            return false
        }
        return lhs == rhs
    }
    
    // MARK: - CustomStringConvertible
    public var description: String {
        self.storage.description
    }

    public var short: String {
        self.storage.short
    }

    /// Returns `true` if the object has a single uniform type
    /// - Always true for non-containers
    /// - True or false for containers
    /// - Never returns `nil`; the optional result is an historical artifact of the API
    public var hasUniformType: Bool? {
        // A container - somewhat expensive to check
        if case .array(let a) = self.storage {
            guard let first = a.first?.celf else {
                return true
            }
            return a.allSatisfy { $0.celf == first && $0.hasUniformType ?? false }
        } else if case .dictionary(let d) = self.storage {
            guard let first = d.values.first?.celf else {
                return true
            }
            return d.values.allSatisfy { $0.celf == first && $0.hasUniformType ?? false }
        }
        // Anything else
        else {
            return true
        }
    }
    
    /// Returns the uniform type of the object, or nil if it is a non-uniform container
    public var uniformType: NaturalType? {
        if self.hasUniformType == false {
            nil
        } else if case .array(let a) = self.storage {
            a.first?.celf ?? .void
        } else if case .dictionary(let d) = self.storage {
            d.values.first?.celf ?? .void
        } else {
            self.storage.concreteType
        }
    }
    
    // MARK: - Generic `LeafDataRepresentable` Initializer
    public init(_ leafData: any LeafDataRepresentable) {
        self = leafData.leafData
    }

    // MARK: - Static Initializer Conformances
    /// Creates a new `LeafData` from a `Bool`.
    public static func bool(_ value: Bool?) -> LeafData {
        value.map { LeafData(.bool($0)) } ?? LeafData(.optional(nil, .bool))
    }
    /// Creates a new `LeafData` from a `String`.
    public static func string(_ value: String?) -> LeafData {
        value.map { LeafData(.string($0)) } ?? LeafData(.optional(nil, .string))
    }
    /// Creates a new `LeafData` from am `Int`.
    public static func int(_ value: Int?) -> LeafData {
        value.map { LeafData(.int($0)) } ?? LeafData(.optional(nil, .int))
    }
    /// Creates a new `LeafData` from a `Double`.
    public static func double(_ value: Double?) -> LeafData {
        value.map { LeafData(.double($0)) } ?? LeafData(.optional(nil, .double))
    }
    /// Creates a new `LeafData` from `Data`.
    public static func data(_ value: Data?) -> LeafData {
        value.map { LeafData(.data($0)) } ?? LeafData(.optional(nil, .data))
    }
    /// Creates a new `LeafData` from `[String: LeafData]`.
    public static func dictionary(_ value: [String: LeafData]?) -> LeafData {
        value.map { LeafData(.dictionary($0)) } ?? LeafData(.optional(nil, .dictionary))
    }
    /// Creates a new `LeafData` from `[LeafData]`.
    public static func array(_ value: [LeafData]?) -> LeafData {
        value.map { LeafData(.array($0)) } ?? LeafData(.optional(nil, .array))
    }
    /// Creates a new `LeafData` for `Optional<LeafData>`
    public static func `nil`(_ type: LeafData.NaturalType) -> LeafData {
        .init(.optional(nil, type))
    }

    // MARK: - Literal Initializer Conformances
    public init(nilLiteral: ()) {
        self = .trueNil
    }

    public init(stringLiteral value: StringLiteralType) {
        self = value.leafData
    }

    public init(integerLiteral value: IntegerLiteralType) {
        self = value.leafData
    }

    public init(floatLiteral value: FloatLiteralType) {
        self = value.leafData
    }

    public init(booleanLiteral value: BooleanLiteralType) {
        self = value.leafData
    }

    public init(arrayLiteral elements: LeafData...) {
        self = .array(elements)
    }

    public init(dictionaryLiteral elements: (String, LeafData)...) {
        self = .dictionary(.init(uniqueKeysWithValues: elements))
    }

    // MARK: - Fuzzy Conversions from Storage to Types

    /// Attempts to convert to `Bool` or returns `nil`.
    public var bool: Bool? {
        if case .bool(let b) = self.storage { return b }
        guard case .bool(let b) = self.convert(to: .bool).storage else { return nil }
        return b
    }

    /// Attempts to convert to `String` or returns `nil`.
    public var string: String? {
        if case .string(let s) = self.storage { return s }
        guard case .string(let s) = self.convert(to: .string).storage else { return nil }
        return s
    }

    /// Attempts to convert to `Int` or returns `nil`.
    public var int: Int? {
        if case .int(let i) = self.storage { return i }
        guard case .int(let i) = self.convert(to: .int).storage else { return nil }
        return i
    }

    /// Attempts to convert to `Double` or returns `nil`.
    public var double: Double? {
        if case .double(let d) = self.storage { return d }
        guard case .double(let d) = self.convert(to: .double).storage else { return nil }
        return d
    }

    /// Attempts to convert to `Data` or returns `nil`.
    public var data: Data? {
        if case .data(let d) = storage { return d }
        guard case .data(let d) = self.convert(to: .data).storage else { return nil }
        return d
    }

    /// Attempts to convert to `[String: LeafData]` or returns `nil`.
    public var dictionary: [String: LeafData]? {
        if case .dictionary(let d) = self.storage { return d }
        guard case .dictionary(let d) = self.convert(to: .dictionary).storage else { return nil }
        return d
    }

    /// Attempts to convert to `[LeafData]` or returns `nil`.
    public var array: [LeafData]? {
        if case .array(let a) = self.storage { return a }
        guard case .array(let a) = self.convert(to: .array).storage else { return nil }
        return a
    }
    
    /// For convenience, `trueNil` is stored as `.optional(nil, .void)`
    public static var trueNil: LeafData {
        .init(.optional(nil, .void))
    }

    public func cast(to: LeafData.NaturalType) -> LeafData {
        self.convert(to: to, .castable)
    }

    public func coerce(to: LeafData.NaturalType) -> LeafData {
        self.convert(to: to, .coercible)
    }

    // MARK: - Internal Only
    
    /// Actual storage.
    private(set) var storage: LeafDataStorage
    
    func serialize() -> String {
        self.storage.serialize()
    }

    func serialize(buffer: inout ByteBuffer) throws {
        try self.storage.serialize(buffer: &buffer)
    }
    
    // Hard resolve data (remove invariants), remaining optional if nil
    var evaluate: LeafData {
        if case .dictionary(let d) = self.storage {
            return .dictionary(d.mapValues { $0.evaluate })
        }
        if case .array(let a) = self.storage {
            return .array(a.map { $0.evaluate })
        }
        return self
    }

    /// Creates a new `LeafData`.
    init(_ storage: LeafDataStorage) {
        self.storage = storage
    }

    /// Try to convert one concrete object to a second type.
    func convert(to output: NaturalType, _ level: DataConvertible = .castable) -> LeafData {
        guard celf != output else  {
            return self
        }

        guard let input = self.storage.unwrap,
              let conversion = _ConverterMap.symbols.get(input.concreteType, output),
              conversion.is >= level
        else {
            return nil
        }
        switch input {
            case .array(let any as Any),
                 .bool(let any as Any),
                 .data(let any as Any),
                 .dictionary(let any as Any),
                 .double(let any as Any),
                 .int(let any as Any),
                 .string(let any as Any):
                return conversion.via(any)
            default:
                return nil
        }
    }

    /// Return a HTML-escaped version of this data if it can be converted to a string.
    func htmlEscaped() -> LeafData {
        guard let string = self.string else {
            return self
        }

        return string.htmlEscaped().leafData
    }
}

// MARK: - Data Converter Static Mapping

/// Stages of convertibility
enum DataConvertible: Int, Equatable, Comparable {
    /// Not implicitly convertible automatically
    case ambiguous = 0
    /// A coercioni with a clear meaning in one direction
    case coercible = 1
    /// A conversion with a well-defined bi-directional casting possibility
    case castable = 2
    /// An exact type match; identity
    case identity = 3
    
    static func < (lhs: DataConvertible, rhs: DataConvertible) -> Bool {
        lhs.rawValue < rhs.rawValue
    }
}

/// Wrapper for associating types and conversion tuple
fileprivate struct Converter: Equatable, Hashable {
    typealias Conversion = (is: DataConvertible, via: (Any) -> LeafData)
    
    let from: LeafData.NaturalType
    let to: LeafData.NaturalType
    let conversion: Conversion?
    
    static func == (lhs: Converter, rhs: Converter) -> Bool {
        lhs.from == rhs.from && lhs.to == rhs.to
    }
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(from)
        hasher.combine(to)
    }
    
    /// Full initializer
    init(
        _ from: LeafData.NaturalType,
        _ to: LeafData.NaturalType,
         `is`: DataConvertible, via: @escaping (Any) -> LeafData
    ) {
        self.from = from
        self.to = to
        self.conversion = (`is`, via)
    }
    
    /// Initializer for the "key" only
    init(_ from: LeafData.NaturalType, _ to: LeafData.NaturalType) {
        self.from = from
        self.to = to
        self.conversion = nil
    }
}

fileprivate extension Set where Element == Converter {
    func get(_ from: LeafData.NaturalType, _ to: LeafData.NaturalType) -> Converter.Conversion? {
        self.first(where: { $0 == .init(from, to) })?.conversion
    }
}
/// Map of functions for converting between concrete, non-nil LeafData
///
/// Purely for pass-through identity, casting, or coercing between the concrete types (Bool, Int, Double,
/// String, Array, Dictionary, Data) and will never attempt to handle optionals, which must *always*
/// be unwrapped to concrete types before being called.
///
/// Converters are guaranteed to be provided non-nil input. Failable converters must return LeafData.trueNil
fileprivate enum _ConverterMap {
    private static let c = LeafConfiguration.self
    fileprivate static var symbols: Set<Converter> { [
        // MARK: - .identity (Passthrough)
        Converter(.array     , .array     , is: .identity, via: { .array($0 as? [LeafData]) }),
        Converter(.bool      , .bool      , is: .identity, via: { .bool($0 as? Bool) }),
        Converter(.data      , .data      , is: .identity, via: { .data($0 as? Data) }),
        Converter(.dictionary, .dictionary, is: .identity, via: { .dictionary($0 as? [String : LeafData]) }),
        Converter(.double    , .double    , is: .identity, via: { .double($0 as? Double) }),
        Converter(.int       , .int       , is: .identity, via: { .int($0 as? Int) }),
        Converter(.string    , .string    , is: .identity, via: { .string($0 as? String) }),

        // MARK: - .castable (Well-defined bi-directional conversions)
                                        // Double in [0,1] == truthiness & value
        Converter(.double  , .bool         , is: .castable, via: {
            ($0 as? Double).map { [0.0, 1.0].contains($0) ? $0 == 1.0 : nil}?
                .map { .bool($0) } ?? .trueNil
        }),
                                        // Int in [0,1] == truthiness & value
        Converter(.int     , .bool         , is: .castable, via: {
            ($0 as? Int).map { [0, 1].contains($0) ? $0 == 1 : nil }?
                .map { .bool($0) } ?? .trueNil
        }),
                                        //  String == "true" || "false"
        Converter(.string  , .bool         , is: .castable, via: {
            ($0 as? String).map { Bool($0) }?.map { .bool($0) } ?? .trueNil
        }),
                                        // True = 1; False = 0
        Converter(.bool    , .double       , is: .castable, via: {
            ($0 as? Bool).map { $0 ? 1.0 : 0.0 }.map { .double($0) } ?? .trueNil
        }),
                                        // Direct conversion
        Converter(.int     , .double       , is: .castable, via: {
            ($0 as? Int).map { Double($0) }.map { .double($0) } ?? .trueNil
        }),
                                        // Using default string-init
        Converter(.string  , .double       , is: .castable, via: {
            ($0 as? String).map { Double($0) }?.map { .double($0) } ?? .trueNil
        }),
                                        // True = 1; False = 0
        Converter(.bool    , .int          , is: .castable, via: {
            ($0 as? Bool).map { $0 ? 1 : 0 }.map { .int($0) } ?? .trueNil
        }),
                                        // Base10 formatted Strings
        Converter(.string  , .int          , is: .castable, via: {
            ($0 as? String).map { Int($0) }?.map { .int($0) } ?? .trueNil
        }),
                                        // .description
        Converter(.bool    , .string       , is: .castable, via: {
            ($0 as? Bool).map { $0.description }.map { .string($0) } ?? .trueNil
        }),
                                        // Using configured encoding
        Converter(.data    , .string       , is: .castable, via: {
            ($0 as? Data).map { String(data: $0, encoding: c.encoding) }?
                .map { .string($0) } ?? .trueNil
        }),
                                        // .description
        Converter(.double  , .string       , is: .castable, via: {
            ($0 as? Double).map { $0.description }.map { .string($0) } ?? .trueNil
        }),
                                        // .description
        Converter(.int     , .string       , is: .castable, via: {
            ($0 as? Int).map { $0.description }.map { .string($0) } ?? .trueNil
        }),
        
        // MARK: - .coercible (One-direction defined conversion)

                                          // Array.isEmpty == truthiness
        Converter(.array      , .bool       , is: .coercible, via: {
            ($0 as? [LeafData]).map { $0.isEmpty }.map { .bool($0) } ?? .trueNil
        }),
                                          // Data.isEmpty == truthiness
        Converter(.data       , .bool       , is: .coercible, via: {
            ($0 as? Data).map { $0.isEmpty }.map { .bool($0) } ?? .trueNil
        }),
                                          // Dictionary.isEmpty == truthiness
        Converter(.dictionary , .bool       , is: .coercible, via: {
            ($0 as? [String: LeafData]).map { $0.isEmpty }.map { .bool($0) } ?? .trueNil
        }),
                                          // Use the configured formatter
        Converter(.array      , .data       , is: .coercible, via: {
            ($0 as? [LeafData]).map {
                LeafDataStorage.array($0).serialize().data(using: c.encoding)
            }?.map { .data($0) } ?? .trueNil
        }),
                                          // Use the configured formatter
        Converter(.bool       , .data       , is: .coercible, via: {
            ($0 as? Bool).map { c.boolFormatter($0).data(using: c.encoding) }?
                .map { .data($0) } ?? .trueNil
        }),
                                          // Use the configured formatter
        Converter(.dictionary , .data       , is: .coercible, via: {
            ($0 as? [String: LeafData]).map {
                LeafDataStorage.dictionary($0).serialize().data(using: c.encoding)
            }?.map { .data($0) } ?? .trueNil
        }),
                                          // Use the configured formatter
        Converter(.double     , .data       , is: .coercible, via: {
            ($0 as? Double).map {
                c.doubleFormatter($0)
                    .data(using: c.encoding)
                }?.map { .data($0) } ?? .trueNil
        }),
                                          // Use the configured formatter
        Converter(.int        , .data       , is: .coercible, via: {
            ($0 as? Int).map { c.intFormatter($0)
                .data(using: c.encoding)
            }?.map { .data($0) } ?? .trueNil
        }),
                                          // Use the configured formatter
        Converter(.string     , .data       , is: .coercible, via: {
            ($0 as? String).map { c.stringFormatter($0)
                .data(using: c.encoding)
            }?.map { .data($0) } ?? .trueNil
        }),
                                          // Schoolbook rounding
        Converter(.double     , .int        , is: .coercible, via: {
            ($0 as? Double).map { Int(exactly: $0.rounded()) }?.map { .int($0) } ?? .trueNil
        }),
        
                                          // Transform with array indices as keys
        Converter(.array      , .dictionary , is: .ambiguous, via: {
            ($0 as? [LeafData]).map {
                Dictionary(uniqueKeysWithValues: $0.enumerated().map {
                                                  (String($0), $1) }) }
                .map { .dictionary($0) } ?? .trueNil
        }),
                                          // Conversion using the formatter
        Converter(.array      , .string     , is: .ambiguous, via: {
            ($0 as? [LeafData]).map {
                .string(LeafData.array($0).serialize())
            } ?? .trueNil
        }),
                                          // Conversion using the formatter
        Converter(.dictionary , .string     , is: .ambiguous, via: {
            ($0 as? [String: LeafData]).map {
                .string(LeafData.dictionary($0).serialize())
            } ?? .trueNil
        }),

        // MARK: - .ambiguous (Unconvertible)
        Converter(.bool      , .array,      is: .ambiguous, via: { _ in nil }),
        Converter(.data      , .array,      is: .ambiguous, via: { _ in nil }),
        Converter(.dictionary, .array,      is: .ambiguous, via: { _ in nil }),
        Converter(.double    , .array,      is: .ambiguous, via: { _ in nil }),
        Converter(.int       , .array,      is: .ambiguous, via: { _ in nil }),
        Converter(.string    , .array,      is: .ambiguous, via: { _ in nil }),
        Converter(.bool      , .dictionary, is: .ambiguous, via: { _ in nil }),
        Converter(.data      , .dictionary, is: .ambiguous, via: { _ in nil }),
        Converter(.double    , .dictionary, is: .ambiguous, via: { _ in nil }),
        Converter(.int       , .dictionary, is: .ambiguous, via: { _ in nil }),
        Converter(.string    , .dictionary, is: .ambiguous, via: { _ in nil }),
        Converter(.array     , .double,     is: .ambiguous, via: { _ in nil }),
        Converter(.data      , .double,     is: .ambiguous, via: { _ in nil }),
        Converter(.dictionary, .double,     is: .ambiguous, via: { _ in nil }),
        Converter(.array     , .int,        is: .ambiguous, via: { _ in nil }),
        Converter(.data      , .int,        is: .ambiguous, via: { _ in nil }),
        Converter(.dictionary, .int,        is: .ambiguous, via: { _ in nil }),
    ] }
}

### File: leaf-kit/Sources/LeafKit/LeafData/LeafDataRepresentable.swift ###
public import struct Foundation.Date
public import struct Foundation.UUID

/// Capable of being encoded as `LeafData`.
public protocol LeafDataRepresentable {
    /// Converts `self` to `LeafData`, returning `nil` if the conversion is not possible.
    var leafData: LeafData { get }
}

// MARK: Default Conformances

extension String: LeafDataRepresentable {
    public var leafData: LeafData {
        .string(self)
    }
}

extension FixedWidthInteger {
    public var leafData: LeafData {
        guard let valid = Int(exactly: self) else {
            return .int(nil)
        }
        return .int(Int(valid))
    }
}

extension Int8: LeafDataRepresentable {}
extension Int16: LeafDataRepresentable {}
extension Int32: LeafDataRepresentable {}
extension Int64: LeafDataRepresentable {}
extension Int: LeafDataRepresentable {}
extension UInt8: LeafDataRepresentable {}
extension UInt16: LeafDataRepresentable {}
extension UInt32: LeafDataRepresentable {}
extension UInt64: LeafDataRepresentable {}
extension UInt: LeafDataRepresentable {}

extension BinaryFloatingPoint {
    public var leafData: LeafData {
        guard let valid = Double(exactly: self) else {
            return .double(nil)
        }
        return .double(Double(valid))
    }
}

extension Float: LeafDataRepresentable {}
extension Double: LeafDataRepresentable {}
#if (canImport(Darwin) || canImport(Glibc)) && (arch(i386) || arch(x86_64))
extension Float80: LeafDataRepresentable {}
#endif

extension Bool: LeafDataRepresentable {
    public var leafData: LeafData {
        .bool(self)
    }
}

extension UUID: LeafDataRepresentable {
    public var leafData: LeafData {
        .string(LeafConfiguration.stringFormatter(self.description))
    }
}

extension Date: LeafDataRepresentable {
    public var leafData: LeafData {
        .double(self.timeIntervalSince1970)
    }
}

extension Array where Element == LeafData {
    public var leafData: LeafData {
        .array(self.map { $0 })
    }
}

extension Dictionary where Key == String, Value == LeafData {
    public var leafData: LeafData {
        .dictionary(self.mapValues { $0 })
    }
}

extension Set where Element: LeafDataRepresentable {
    public var leafData: LeafData {
        .array(self.map { $0.leafData })
    }
}

extension Array where Element: LeafDataRepresentable {
    public var leafData: LeafData {
        .array(self.map { $0.leafData })
    }
}

extension Dictionary where Key == String, Value: LeafDataRepresentable {
    public var leafData: LeafData {
        .dictionary(self.mapValues { $0.leafData })
    }
}

### File: leaf-kit/Sources/LeafKit/LeafData/LeafDataStorage.swift ###
import Foundation
import NIOCore
import NIOFoundationCompat

indirect enum LeafDataStorage: Equatable, CustomStringConvertible, Sendable {
    // MARK: - Cases
    
    // Static values
    case bool(Bool)
    case string(String)
    case int(Int)
    case double(Double)
    case data(Data)
    
    // Collections
    case dictionary([String: LeafData])
    case array([LeafData])

    // Wrapped `Optional<LeafDataStorage>`
    case optional(_ wrapped: LeafDataStorage?, _ type: LeafData.NaturalType)
    
    // MARK: Properties

    var concreteType: LeafData.NaturalType {
        switch self {
        // Concrete Types
        case .array:      .array
        case .bool:       .bool
        case .data:       .data
        case .dictionary: .dictionary
        case .double:     .double
        case .int:        .int
        case .string:     .string
        // Optional Types
        case .optional(_, let t): t
        }
    }
    
    // MARK: Functions

    /// Will resolve anything and unwrap optionals
    func resolve() -> LeafDataStorage {
        return switch self {
        case .optional(let o, _): o ?? self
        case .array(let a):       .array(a.map { .init($0.storage.resolve()) })
        case .dictionary(let d):  .dictionary(d.mapValues { .init($0.storage.resolve()) })
        default:                  self
        }
    }

    /// Serialize anything to a string.
    func serialize() -> String {
        switch self {
        case .bool(let b):        LeafConfiguration.boolFormatter(b)
        case .int(let i):         LeafConfiguration.intFormatter(i)
        case .double(let d):      LeafConfiguration.doubleFormatter(d)
        case .string(let s):      LeafConfiguration.stringFormatter(s)
        case .data(let d):        LeafConfiguration.dataFormatter(d) ?? LeafConfiguration.nilFormatter()
        case .optional(let o, _): o?.serialize() ?? LeafConfiguration.nilFormatter()
        case .array(let a):       LeafConfiguration.arrayFormatter(a.map { $0.storage.serialize() })
        case .dictionary(let d):  LeafConfiguration.dictFormatter(d.mapValues { $0.storage.serialize() })
        }
    }
    
    /// Final serialization to a shared buffer
    func serialize(buffer: inout ByteBuffer) throws {
        switch self {
        case .bool, .int, .double, .string, .optional, .array, .dictionary:
            try buffer.writeString(self.serialize(), encoding: LeafConfiguration.encoding)
        case .data(let d):
            buffer.writeData(d)
        }
    }
    
    // MARK: - Equatable Conformance
   
    /// Strict equality comparision, with nil being equal
    static func == (lhs: LeafDataStorage, rhs: LeafDataStorage) -> Bool {
        switch (lhs, rhs) {
        // Both optional and nil
        case (.optional(nil, _),    .optional(nil, _)):    true
        // Both optional and non-nil
        case (.optional(let l?, _), .optional(let r?, _)): l == r
        // One or the other optional and non-nil, unwrap and compare
        case (.optional(let l?, _), let r),
             (let l, .optional(let r?, _)):                l == r

        // Direct concrete type comparisons
        case (     .array(let l),      .array(let r)):     l == r
        case (.dictionary(let l), .dictionary(let r)):     l == r
        case (      .bool(let l),       .bool(let r)):     l == r
        case (    .string(let l),     .string(let r)):     l == r
        case (       .int(let l),        .int(let r)):     l == r
        case (    .double(let l),     .double(let r)):     l == r
        case (      .data(let l),       .data(let r)):     l == r

        // Any other combo is unequal
        default:                                           false
        }
    }
    
    // MARK: - CustomStringConvertible
    var description: String {
        switch self {
            case .array(let a):       "array(\(a.count))"
            case .bool(let b):        "bool(\(b))"
            case .data(let d):        "data(\(d.count))"
            case .dictionary(let d):  "dictionary(\(d.count))"
            case .double(let d):      "double(\(d))"
            case .int(let i):         "int(\(i))"
            case .optional(let o, _): "optional(\(o.map { "\($0)" } ?? "nil")))"
            case .string(let s):      "string(\(s))"
        }
    }
    
    var short: String {
        self.serialize()
    }

    // MARK: - Other
    var isNil: Bool {
        switch self {
        case .optional(.none, _): true
        default: false
        }
    }
    
    /// Flat mapping behavior, turns non-optional into optional. Will never re-wrap optional.
    var wrap: LeafDataStorage {
        switch self {
        case .optional: self
        default: .optional(self, self.concreteType)
        }
    }

    /// Unwrap storage optional to Swift optional.
    var unwrap: LeafDataStorage? {
        switch self {
        case .optional(let optional, _): optional
        default: self
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafLexer/LeafLexer.swift ###
import Foundation

// MARK: `LeafLexer` Summary

/// `LeafLexer` is an opaque structure that wraps the lexing logic of Leaf-Kit.
///
/// Initialized with a `LeafRawTemplate` (raw string-providing representation of a file or other source),
/// used by evaluating with `LeafLexer.lex()` and either erroring or returning `[LeafToken]`
struct LeafLexer {
    // MARK: - Internal Only
    
    /// Convenience to initialize `LeafLexer` with a `String`
    init(name: String, template string: String) {
        self.name = name
        self.src = LeafRawTemplate(name: name, src: string)
        self.state = .raw
    }
    
    /// Init with `LeafRawTemplate`
    init(name: String, template: LeafRawTemplate) {
        self.name = name
        self.src = template
        self.state = .raw
    }
    
    /// Lex the stored `LeafRawTemplate`
    /// - Throws: `LexerError`
    /// - Returns: An array of fully built `LeafTokens`, to then be parsed by `LeafParser`
    mutating func lex() throws -> [LeafToken] {
        while let next = try self.nextToken() {
            self.lexed.append(next)
            self.offset += 1
        }
        return self.lexed
    }
    
    // MARK: - Private Only
    
    private enum State {
        /// Parse as raw, until it finds `#` (but consuming escaped `\#`)
        case raw
        /// Start attempting to sequence tag-viable tokens (tagName, parameters, etc)
        case tag
        /// Start attempting to sequence parameters
        case parameters
        /// Start attempting to sequence a tag body
        case body
    }
    
    /// Current state of the Lexer
    private var state: State
    /// Current parameter depth, when in a Parameter-lexing state
    private var depth = 0
    /// Current index in `lexed` that we want to insert at
    private var offset = 0
    /// Streat of `LeafTokens` that have been successfully lexed
    private var lexed: [LeafToken] = []
    /// The originating template source content (ie, raw characters)
    private var src: LeafRawTemplate
    /// Name of the template (as opposed to file name) - eg if file = "/views/template.leaf", `template`
    private var name: String
    
    // MARK: - Private - Actual implementation of Lexer

    private mutating func nextToken() throws -> LeafToken? {
        // if EOF, return nil - no more to read
        guard let current = self.src.peek() else {
            return nil
        }
        let isTagID = current == LeafConfiguration.tagIndicator
        let isTagVal = current.isValidInTagName
        let isCol = current == .colon
        let next = self.src.peek(aheadBy: 1)

        switch   (self.state,  isTagID, isTagVal, isCol, next) {
            case (.raw,        false,   _,        _,     _):     return self.lexRaw()
            case (.raw,        true,    _,        _,     .some): return self.lexCheckTagIndicator()
            case (.tag,        _,       true,     _,     _):     return self.lexNamedTag()
            case (.tag,        _,       false,    _,     _):     return self.lexAnonymousTag()
            case (.parameters, _,   _,   _,  _):                 return try self.lexParameters()
            case (.body,       _,   _, true,  _):                return self.lexBodyIndicator()
            /// Ambiguous case  - `#endTagName#` at EOF. Should this result in `tag(tagName),raw(#)`?
            case (.raw,        true,    _,        _,     .none):
                throw LexerError(.unknownError("Unescaped # at EOF"), src: self.src, lexed: self.lexed)
            default:
                throw LexerError(.unknownError("Template cannot be lexed"), src: self.src, lexed: self.lexed)
        }
    }

    // Lexing subroutines that can produce state changes:
    // * to .raw:           lexRaw, lexCheckTagIndicator
    // * to .tag:           lexCheckTagIndicator
    // * to .parameters:    lexAnonymousTag, lexNamedTag
    // * to .body:          lexNamedTag

    private mutating func lexAnonymousTag() -> LeafToken {
        self.state = .parameters
        self.depth = 0
        return .tag(name: "")
    }

    private mutating func lexNamedTag() -> LeafToken {
        let name = self.src.readWhile { $0.isValidInTagName }
        let trailing = self.src.peek()

        self.state = .raw
        if trailing == .colon {
            self.state = .body
        } else if trailing == .leftParenthesis {
            self.state = .parameters
            self.depth = 0
        }
        return .tag(name: name)
    }

    /// Consume all data until hitting an unescaped `tagIndicator` and return a `.raw` token
    private mutating func lexRaw() -> LeafToken {
        var slice = ""
        while let current = self.src.peek(), current != LeafConfiguration.tagIndicator {
            slice += self.src.readWhile {
                $0 != LeafConfiguration.tagIndicator && $0 != .backSlash
            }
            guard let newCurrent = self.src.peek(), newCurrent == .backSlash else {
                break
            }
            if let next = self.src.peek(aheadBy: 1), next == LeafConfiguration.tagIndicator {
                self.src.pop()
            }
            slice += self.src.pop()!.description
        }
        return .raw(slice)
    }

    /// Consume `#`, change state to `.tag` or `.raw`, return appropriate token
    private mutating func lexCheckTagIndicator() -> LeafToken {
        // consume `#`
        self.src.pop()
        // if tag indicator is followed by an invalid token, assume that it is unrelated to leaf
        let current = self.src.peek()
        if let current = current, current.isValidInTagName || current == .leftParenthesis {
            self.state = .tag
            return .tagIndicator
        } else {
            self.state = .raw
            return .raw(LeafConfiguration.tagIndicator.description)
        }
    }

    /// Consume `:`, change state to `.raw`, return `.tagBodyIndicator`
    private mutating func lexBodyIndicator() -> LeafToken {
        self.src.pop()
        self.state = .raw
        return .tagBodyIndicator
    }

    /// Parameter hot mess
    private mutating func lexParameters() throws -> LeafToken {
        // consume first character regardless of what it is
        let current = self.src.pop()!

        // Simple returning cases - .parametersStart/Delimiter/End, .whitespace, .stringLiteral Parameter
        switch current {
            case .leftParenthesis:
                self.depth += 1
                return .parametersStart
            case .rightParenthesis:
                switch (self.depth <= 1, self.src.peek() == .colon) {
                    case (true, true):  self.state = .body
                    case (true, false): self.state = .raw
                    case (false, _):    self.depth -= 1
                }
                return .parametersEnd
            case .comma:
                return .parameterDelimiter
            case .quote:
                let read = self.readWithEscapingQuotes(src: &src)
                guard self.src.peek() == .quote else {
                    throw LexerError(.unterminatedStringLiteral, src: self.src, lexed: self.lexed)
                }
                src.pop() // consume final quote
                return .parameter(.stringLiteral(read))
            case .space:
                let read = self.src.readWhile { $0 == .space }
                return .whitespace(length: read.count + 1)
            default: break
        }

        // Complex Parameter lexing situations - enhanced to allow non-whitespace separated values
        // Complicated by overlap in acceptable isValidInParameter characters between possible types
        // Process from most restrictive options to least to help prevent overly aggressive tokens
        // Possible results, most restrictive to least
        // * Operator
        // * Constant(Int)
        // * Constant(Double)
        // * Keyword
        // * Tag
        // * Variable

        // if current character isn't valid for any kind of parameter, something's majorly wrong
        guard current.isValidInParameter else {
            throw LexerError(.invalidParameterToken(current), src: self.src, lexed: self.lexed)
        }

        // Test for Operator first - this will only handle max two character operators, not ideal
        // Can't switch on this, MUST happen before trying to read tags
        if current.isValidOperator {
            // Try to get a valid 2char Op
            var op = LeafOperator(rawValue: String(current) + String(self.src.peek()!))
            if op != nil, !op!.available { throw LeafError(.unknownError("\(op!) is not yet supported as an operator")) }
            if op == nil { op = LeafOperator(rawValue: String(current)) } else { self.src.pop() }
            if op != nil, !op!.available { throw LeafError(.unknownError("\(op!) is not yet supported as an operator")) }
            return .parameter(.operator(op!))
        }

        // Test for numerics next. This is not very intelligent but will read base2/8/10/16
        // for Ints and base 10/16 for decimal through native Swift initialization
        // Will not adequately decay to handle things like `0b0A` and recognize as invalid.
        if current.canStartNumeric {
            var testInt: Int?
            var testDouble: Double?
            var radix: Int? = nil
            var sign = 1

            let next = self.src.peek()!
            let peekRaw = String(current) + (self.src.peekWhile { $0.isValidInNumeric })
            var peekNum: String
            if #available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *) {
                peekNum = peekRaw.replacing(String(.underscore), with: "")
            } else {
                peekNum = peekRaw.replacingOccurrences(of: String(.underscore), with: "")
            }
            // We must be immediately preceeded by a minus to flip the sign
            // And only flip back if immediately preceeded by a const, tag or variable
            // (which we assume will provide a numeric). Grammatical errors in the
            // template (eg, keyword-numeric) may throw here
            if case .parameter(let p) = self.lexed[self.offset - 1],
               case .operator(let op) = p,
               op == .minus
            {
                switch self.lexed[self.offset - 2] {
                case .parameter(let p):
                    switch p {
                    case .constant,
                         .tag,
                         .variable: sign = 1
                    default:
                        throw LexerError(.invalidParameterToken("-"), src: self.src)
                    }
                case .stringLiteral:
                    throw LexerError(.invalidParameterToken("-"), src: self.src)
                default:
                    sign = -1
                }
            }

            switch (peekNum.contains(.period), next, peekNum.count > 2) {
                case (true, _, _) :                  testDouble = Double(peekNum)
                case (false, .binaryNotation, true): radix = 2
                case (false, .octalNotation, true):  radix = 8
                case (false, .hexNotation, true):    radix = 16
                default:                             testInt = Int(peekNum)
            }

            if let radix {
                let start = peekNum.startIndex
                peekNum.removeSubrange(start ... peekNum.index(after: start))
                testInt = Int(peekNum, radix: radix)
            }

            if testInt != nil || testDouble != nil {
                // discard the minus
                if sign == -1 {
                    self.lexed.removeLast()
                    self.offset -= 1
                }
                self.src.popWhile { $0.isValidInNumeric }
                if let testInt {
                    return .parameter(.constant(.int(testInt * sign)))
                } else if let testDouble {
                    return .parameter(.constant(.double(testDouble * Double(sign))))
                }
            }
        }

        // At this point, just read anything that's parameter valid, but not an operator,
        // Could be handled better and is probably way too aggressive.
        let name = String(current) + self.src.readWhile { $0.isValidInParameter && !$0.isValidOperator }

        // If it's a keyword, return that
        if let keyword = LeafKeyword(rawValue: name) {
            return .parameter(.keyword(keyword))
        }
        // Assume anything that matches .isValidInTagName is a tag
        // Parse can decay to a variable if necessary - checking for a paren
        // is over-aggressive because a custom tag may not take parameters
        let tagValid = name.compactMap { $0.isValidInTagName ? $0 : nil }.count == name.count

        if tagValid && self.src.peek()! == .leftParenthesis {
            return .parameter(.tag(name: name))
        } else {
            return .parameter(.variable(name: name))
        }
    }

    private func readWithEscapingQuotes(src: inout LeafRawTemplate) -> String {
        let read = src.readWhile {
            $0 != .quote && $0 != .newLine
        }
        if read.last == .backSlash, src.peek() == .quote {
            src.pop()
            return read.dropLast() + "\"" + self.readWithEscapingQuotes(src: &src)
        } else {
            return read
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafLexer/LeafParameterTypes.swift ###
// MARK: - `Parameter` Token Type

/// An associated value enum holding data, objects or values usable as parameters to a `.tag`
public enum Parameter: Equatable, CustomStringConvertible, Sendable {
    case stringLiteral(String)
    case constant(Constant)
    case variable(name: String)
    case keyword(LeafKeyword)
    case `operator`(LeafOperator)
    case tag(name: String)
    
    /// Returns `parameterCase(parameterValue)`
    public var description: String {
        "\(self.name)(\(self.short))"
    }
    
    /// Returns `parameterCase`
    var name: String {
        switch self {
        case .stringLiteral: "stringLiteral"
        case .constant:      "constant"
        case .variable:      "variable"
        case .keyword:       "keyword"
        case .operator:      "operator"
        case .tag:           "tag"
        }
    }
    
    /// Returns `parameterValue` or `"parameterValue"` as appropriate for type
    var short: String {
        switch self {
        case .stringLiteral(let s): "\"\(s)\""
        case .constant(let c):      "\(c)"
        case .variable(let v):      "\(v)"
        case .keyword(let k):       "\(k)"
        case .operator(let o):      "\(o)"
        case .tag(let t):           "\"\(t)\""
        }
    }
}

// MARK: - `Parameter`-Storable Types

/// `Keyword`s are identifiers which take precedence over syntax/variable names - may potentially have
/// representable state themselves as value when used with operators (eg, `true`, `false` when
/// used with logical operators, `nil` when used with equality operators, and so forth)
public enum LeafKeyword: String, Equatable, Sendable {
    // MARK: Public - Cases
    
    //                      Eval -> Bool / Other
    //                   -----------------------
    case `in`,           //
         `true`,         //   X       T
         `false`,        //   X       F
         this = "self",  //   X             X
         `nil`,          //   X       F     X
         `yes`,          //   X       T
         `no`            //   X       F

    // MARK: Internal Only
    
    // State booleans
    var isEvaluable: Bool {
        self != .in
    }

    var isBooleanValued: Bool {
        [.true, .false, .nil, .yes, .no].contains(self)
    }

    // Value or value-indicating returns
    var `nil`: Bool {
        self == .nil
    }

    var identity: Bool {
        self == .this
    }

    var bool: Bool? {
        guard self.isBooleanValued else {
            return nil
        }
        return [.true, .yes].contains(self)
    }
}

extension LeafKeyword {
     @available(*, deprecated, message: "Use .this instead")
     static var `self`: Self { this }
 }

// MARK: - Operator Symbols

/// Mathematical and Logical operators
public enum LeafOperator: String, Equatable, CustomStringConvertible, CaseIterable, Sendable {
    // MARK: Public - Cases
    
    // Operator types:              Logic      Exist.       UnPre        Scope
    //                                |   Math    |   Infix   |   UnPost   |
    //   Logical Tests          --------------------------------------------
    case not = "!"              //    X                       X
    case equal = "=="           //    X                 X
    case unequal = "!="         //    X                 X
    case greater = ">"          //    X                 X
    case greaterOrEqual = ">="  //    X                 X
    case lesser = "<"           //    X                 X
    case lesserOrEqual = "<="   //    X                 X
    case and = "&&"             //    X                 X
    case or = "||"              //    X                 X
    //   Mathematical Calcs     // -----------------------------------------
    case plus = "+"             //          X           X
    case minus = "-"            //          X     X     X     X
    case divide = "/"           //          X           X
    case multiply = "*"         //          X           X
    case modulo = "%"           //          X           X
    //   Assignment/Existential //
    case assignment = "="       //                X     X
    case nilCoalesce = "??"     //                X     X
    case evaluate = "`"         //                X           X
    //   Scoping
    case scopeRoot = "$"        //                            X           X
    case scopeMember = "."      //                      X                 X
    case subOpen = "["          //                      X                 X
    case subClose = "]"         //                                  X     X
    
    /// Raw string value of the operator - eg `!=`
    public var description: String {
        self.rawValue
    }

    // MARK: Internal Only
    
    // State booleans
    var logical: Bool {
        Self.states["logical"]!.contains(self)
    }

    var mathematical: Bool {
        Self.states["mathematical"]!.contains(self)
    }

    var existential: Bool {
        Self.states["existential"]!.contains(self)
    }

    var scoping: Bool {
        Self.states["scoping"]!.contains(self)
    }

    var unaryPrefix: Bool {
        Self.states["unaryPrefix"]!.contains(self)
    }

    var unaryPostfix: Bool {
        Self.states["unaryPostfix"]!.contains(self)
    }

    var infix: Bool {
        Self.states["unaryPostfix"]!.contains(self)
    }

    var available: Bool {
        !Self.states["unavailable"]!.contains(self)
    }

    static let precedenceMap: [(check: (@Sendable (LeafOperator) -> Bool), infixed: Bool)] = [
        (check: { $0 == .not }, infixed: false), // unaryNot
        (check: { $0 == .multiply || $0 == .divide || $0 == .modulo }, infixed: true), // Mult/Div/Mod
        (check: { $0 == .plus || $0 == .minus }, infixed: true), // Plus/Minus
        (check: { $0 == .greater || $0 == .greaterOrEqual }, infixed: true), // >, >=
        (check: { $0 == .lesser || $0 == .lesserOrEqual }, infixed: true), // <, <=
        (check: { $0 == .equal || $0 == .unequal }, infixed: true), // !, !=
        (check: { $0 == .and || $0 == .or }, infixed: true), // &&, ||
    ]
    
    // MARK: Private Only
    
    private static let states: [String: Set<LeafOperator>] = [
        "logical"       : [.not, .equal, .unequal, .greater, .greaterOrEqual,
                           .lesser, .lesserOrEqual, .and, .or],
        "mathematical"  : [.plus, .minus, .divide, .multiply, modulo],
        "existential"   : [.assignment, .nilCoalesce, .minus, .evaluate],
        "scoping"       : [.scopeRoot, .scopeMember, .subOpen, .subClose],
        "unaryPrefix"   : [.not, .minus, .evaluate, .scopeRoot],
        "unaryPostfix"  : [.subClose],
        "infix"         : [.equal, .unequal, .greater, .greaterOrEqual, .lesser,
                           .lesserOrEqual, .and, .or, .plus, .minus, .divide,
                           .multiply, .modulo, .assignment, .nilCoalesce,
                           .scopeMember, .subOpen],
        "unavailable"   : [.assignment, .nilCoalesce, .evaluate, .scopeRoot,
                           .scopeMember, .subOpen, .subClose]
    ]
}

/// An integer or double constant value parameter (eg `1_000`, `-42.0`)
public enum Constant: CustomStringConvertible, Equatable, Sendable {
    case int(Int)
    case double(Double)

    public var description: String {
        switch self {
            case .int(let i):    i.description
            case .double(let d): d.description
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafLexer/LeafRawTemplate.swift ###
struct LeafRawTemplate {
    // MARK: - Internal Only
    let name: String
    
    init(name: String, src: String) {
        self.name = name
        self.body = src
        self.current = body.startIndex
    }

    mutating func readWhile(_ check: (Character) -> Bool) -> String {
        .init(self.readSliceWhile(pop: true, check))
    }

    mutating func peekWhile(_ check: (Character) -> Bool) -> String {
        .init(self.peekSliceWhile(check))
    }
    
    @discardableResult
    mutating func popWhile(_ check: (Character) -> Bool) -> Int {
        self.readSliceWhile(pop: true, check).count
    }

    func peek(aheadBy idx: Int = 0) -> Character? {
        let peekIndex = self.body.index(self.current, offsetBy: idx)
        guard peekIndex < self.body.endIndex else {
            return nil
        }
        return self.body[peekIndex]
    }

    @discardableResult
    mutating func pop() -> Character? {
        guard self.current < self.body.endIndex else {
            return nil
        }
        if self.body[self.current] == .newLine {
            self.line += 1
            self.column = 0
        } else {
            self.column += 1
        }
        defer { self.current = self.body.index(after: self.current) }
        return self.body[self.current]
    }
    
    // MARK: - Private Only
    
    private(set) var line = 0
    private(set) var column = 0

    private let body: String
    private var current: String.Index
    
    mutating private func readSliceWhile(pop: Bool, _ check: (Character) -> Bool) -> [Character] {
        var str = [Character]()
        str.reserveCapacity(512)
        while let next = self.peek() {
            guard check(next) else {
                return str
            }
            if pop {
                self.pop()
            }
            str.append(next)
        }
        return str
    }

    mutating private func peekSliceWhile(_ check: (Character) -> Bool) -> [Character] {
        var str = [Character]()
        str.reserveCapacity(512)
        var index = 0
        while let next = self.peek(aheadBy: index) {
            guard check(next) else {
                return str
            }
            str.append(next)
            index += 1
        }
        return str
    }
}

### File: leaf-kit/Sources/LeafKit/LeafLexer/LeafToken.swift ###
// MARK: `LeafToken` Summary

/// `LeafToken` represents the first stage of parsing Leaf templates - a raw file/bytestream `String`
/// will be read by `LeafLexer` and interpreted into `[LeafToken]` representing a stream of tokens.
///
/// # STABLE TOKEN DEFINITIONS
/// - `.raw`: A variable-length string of data that will eventually be output directly without processing
/// - `.tagIndicator`: The signal at top-level that a Leaf syntax object will follow. Default is `#` and
///     while it can be configured to be something else, only rare uses cases may want to do so.
///     `.tagindicator` can be escaped in source templates with a backslash and will automatically
///     be consumed by `.raw` if so. May decay to `.raw` at the token parsing stage if a non-
///     tag/syntax object follows.
/// - `.tag`: The expected tag name - in `#for(index in array)`, equivalent token is `.tag("for")`
/// - `.tagBodyIndicator`: Indicates the start of a body-bearing tag - ':'
/// - `.parametersStart`: Indicates the start of a tag's parameters - `(`
/// - `.parameterDelimiter`: Indicates a delimter between parameters - `,`
/// - `.parameter`: Associated value enum storing a valid tag parameter.
/// - `.parametersEnd`: Indicates the end of a tag's parameters - `)`
///
/// # POTENTIALLY UNSTABLE TOKENS
/// - `.stringLiteral`: Does not appear to be used anywhere?
/// - `.whitespace`: Only generated when not at top-level, and unclear why maintaining it is useful
///

enum LeafToken: CustomStringConvertible, Equatable  {
    /// Holds a variable-length string of data that will be passed through with no processing
    case raw(String)
    
    /// `#` (or as configured) - Top-level signal that indicates a Leaf tag/syntax object will follow.
    case tagIndicator
    /// Holds the name of an expected tag or syntax object (eg, `for`) in `#for(index in array)`
    case tag(name: String)
    /// `:` - Indicates the start of a body for a body-bearing tag
    case tagBodyIndicator

    /// `(` -  Indicates the start of a tag's parameters
    case parametersStart
    /// `,` -  Indicates separation of a tag's parameters
    case parameterDelimiter
    /// Holds a `Parameter` enum
    case parameter(Parameter)
    /// `)` -  Indicates the end of a tag's parameters
    case parametersEnd

    /// To be removed if possible - avoid using
    case stringLiteral(String)
    /// To be removed if possible - avoid using
    case whitespace(length: Int)
    
    /// Returns `"tokenCase"` or `"tokenCase(valueAsString)"` if holding a value
    var description: String {
        switch self {
        case .raw(let str):
            "raw(\(str.debugDescription))"
        case .tagIndicator:
            "tagIndicator"
        case .tag(let name):
            "tag(name: \(name.debugDescription))"
        case .tagBodyIndicator:
            "tagBodyIndicator"
        case .parametersStart:
            "parametersStart"
        case .parametersEnd:
            "parametersEnd"
        case .parameterDelimiter:
            "parameterDelimiter"
        case .parameter(let param):
            "param(\(param))"
        case .stringLiteral(let string):
            "stringLiteral(\(string.debugDescription))"
        case .whitespace(let length):
            "whitespace(\(length))"
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafParser/LeafParameter.swift ###
import NIOCore

public indirect enum ParameterDeclaration: CustomStringConvertible, Sendable {
    case parameter(Parameter)
    case expression([ParameterDeclaration])
    case tag(Syntax.CustomTagDeclaration)

    public var description: String {
        switch self {
        case .parameter(let p): p.description
        case .expression(_):    self.short
        case .tag(let t):       "tag(\(t.name): \(t.params.describe(",")))"
        }
    }

    var short: String {
        switch self {
        case .parameter(let p):  p.short
        case .expression(let p): "[\(p.describe())]"
        case .tag(let t):        "\(t.name)(\(t.params.describe(",")))"
        }
    }

    var name: String {
        switch self {
        case .parameter:  "parameter"
        case .expression: "expression"
        case .tag:        "tag"
        }
    }
    
    // MARK: - Internal Only
    
    func imports() -> Set<String> {
        switch self {
        case .parameter(_):
            return .init()
        case .expression(let e):
            return e.imports()
        case .tag(let t):
            guard t.name == "import" else {
                return t.imports()
            }
            guard let parameter = t.params.first,
                  case .parameter(let p) = parameter,
                  case .stringLiteral(let key) = p,
                  !key.isEmpty
            else {
                return .init()
            }
            return .init(arrayLiteral: key)
        }
    }
    
    func inlineImports(_ imports: [String : Syntax.Export]) -> ParameterDeclaration {
        switch self {
        case .parameter(_):
            return self
        case .tag(let t):
            guard t.name == "import" else {
                return .tag(.init(name: t.name, params: t.params.inlineImports(imports)))
            }
            guard let parameter = t.params.first,
                  case .parameter(let p) = parameter,
                  case .stringLiteral(let key) = p,
                  let export = imports[key]?.body.first,
                  case .expression(let exp) = export,
                  exp.count == 1,
                  let e = exp.first
            else {
                return self
            }
            return e
        case .expression(let e):
            guard !e.isEmpty else {
                return self
            }
            return .expression(e.inlineImports(imports))
        }
    }
}

// MARK: - Internal Helper Extensions

extension Array where Element == ParameterDeclaration {
    // evaluate a flat array of Parameters ("Expression")
    // returns true if the expression was reduced, false if
    // not or if unreducable (eg, non-flat or no operands).
    // Does not promise that the resulting Expression is valid.
    // This is brute force and not very efficient.
    @discardableResult mutating func evaluate() -> Bool {
        // Expression with no operands can't be evaluated
        var ops = self.operandCount()
        guard ops > 0 else {
            return false
        }
        // check that the last param isn't an op, this is not resolvable
        // since there are no unary postfix options currently
        guard self.last?.operator() == nil else {
            return false
        }

        groupOps: for map in LeafOperator.precedenceMap {
            while let i = self.findLastOpWhere(map.check) {
                if map.infixed {
                    self.wrapBinaryOp(i)
                } else {
                    self.wrapUnaryNot(i)
                }
                // Some expression could not be wrapped - probably malformed syntax
                if ops == self.operandCount() {
                    return false
                }
                ops -= 1
                if self.operandCount() == 0 {
                    break groupOps
                }
            }
        }

        self.flatten()
        return ops > 1
    }

    mutating func flatten() {
        while self.count == 1 {
            guard case .expression(let e) = self.first! else {
                return
            }
            self.removeAll()
            self.append(contentsOf: e)
        }
    }

    fileprivate mutating func wrapUnaryNot(_ i: Int) {
        let rhs = self.remove(at: i + 1)
        if case .parameter(let p) = rhs, case .keyword(let key) = p, key.isBooleanValued {
            self[i] = .parameter(.keyword(LeafKeyword(rawValue: String(!key.bool!))!))
        } else {
            self[i] = .expression([self[i], rhs])
        }
    }

    // could be smarter and check param types beyond verifying non-op but we're lazy here
    fileprivate mutating func wrapBinaryOp(_ i: Int) {
        // can't wrap unless there's a lhs and rhs
        guard self.indices.contains(i - 1), self.indices.contains(i+1) else {
            return
        }
        let lhs = self[i - 1]
        let rhs = self[i + 1]
        // can't wrap if lhs or rhs is an operator
        if case .parameter(.operator) = lhs {
            return
        }
        if case .parameter(.operator) = rhs {
            return
        }
        self[i] = .expression([lhs, self[i], rhs])
        self.remove(at: i + 1)
        self.remove(at: i - 1)
    }

    // Helper functions
    func operandCount() -> Int {
        self.reduceOpWhere { _ in true }
    }

    func unaryOps() -> Int {
        self.reduceOpWhere { $0.unaryPrefix }
    }

    func binaryOps() -> Int {
        self.reduceOpWhere { $0.infix }
    }

    func reduceOpWhere(_ check: (LeafOperator) -> Bool) -> Int {
        self.reduce(0, { count, pD  in
            count + (pD.operator().map { check($0) ? 1 : 0 } ?? 0)
        })
    }

    func findLastOpWhere(_ check: (LeafOperator) -> Bool) -> Int? {
        for (index, pD) in self.enumerated().reversed() {
            if let op = pD.operator(), check(op) {
                return index
            }
        }
        return nil
    }
    
    func describe(_ joinBy: String = " ") -> String {
        self.map { $0.short }.joined(separator: joinBy)
    }
    
    func imports() -> Set<String> {
        var result = Set<String>()
        self.forEach { result.formUnion($0.imports()) }
        return result
    }
    
    func inlineImports(_ imports: [String : Syntax.Export]) -> [ParameterDeclaration] {
        guard !self.isEmpty, !imports.isEmpty else {
            return self
        }
        return self.map { $0.inlineImports(imports) }
    }
    
    func atomicRaw() -> Syntax? {
        // only atomic expressions can be converted
        guard self.count < 2 else {
            return nil
        }

        var buffer = ByteBuffer()
        // empty expressions = empty raw
        guard self.count == 1 else {
            return .raw(buffer)
        }
        // only single value parameters can be converted
        guard case .parameter(let p) = self[0] else {
            return nil
        }
        switch p {
        case .constant(let c):
            buffer.writeString(c.description)
        case .keyword(let k):
            buffer.writeString(k.rawValue)
        case .operator(let o):
            buffer.writeString(o.rawValue)
        case .stringLiteral(let s):
            buffer.writeString(s)
        // .tag, .variable not atomic
        default:
            return nil
        }
        return .raw(buffer)
    }
}

### File: leaf-kit/Sources/LeafKit/LeafParser/LeafParser.swift ###
import NIOCore

// This is a horrible, horrible mistake, it really stinks that it can't be taken back.
extension Swift.String: Swift.Error {}

struct LeafParser {
    // MARK: - Internal Only
    
    let name: String

    init(name: String, tokens: [LeafToken]) {
        self.name = name
        self.tokens = tokens
        self.offset = 0
    }
    
    mutating func parse() throws -> [Syntax] {
        while let next = self.peek() {
            try self.handle(next: next)
        }
        return self.finished
    }
    
    // MARK: - Private Only
    
    private var tokens: [LeafToken]
    private var offset: Int
    
    private var finished: [Syntax] = []
    private var awaitingBody: [OpenContext] = []

    private mutating func handle(next: LeafToken) throws {
        switch next {
        case .tagIndicator:
            let declaration = try self.readTagDeclaration()
            // check terminator first
            // always takes priority, especially for dual body/terminator functors
            if declaration.isTerminator {
                try self.close(with: declaration)
            }

            // this needs to be a secondary if-statement, and
            // not joined above
            //
            // this allows for dual functors, a la elseif
            if declaration.expectsBody {
                self.awaitingBody.append(.init(declaration))
            } else if declaration.isTerminator {
                // dump terminators that don't also have a body,
                // already closed above
                // MUST close FIRST (as above)
                return
            } else {
                let syntax = try declaration.makeSyntax(body: [])
                if var last = self.awaitingBody.last {
                    last.body.append(syntax)
                    self.awaitingBody.removeLast()
                    self.awaitingBody.append(last)
                } else {
                    self.finished.append(syntax)
                }
            }
        case .raw:
            let r = try self.collectRaw()
            if var last = self.awaitingBody.last {
                last.body.append(.raw(r))
                self.awaitingBody.removeLast()
                self.awaitingBody.append(last)
            } else {
                self.finished.append(.raw(r))
            }
        default:
            throw LeafError(.unknownError("unexpected token \(next)"))
        }
    }

    private mutating func close(with terminator: TagDeclaration) throws {
        guard !self.awaitingBody.isEmpty else {
            throw LeafError(.unknownError("\(self.name): found terminator \(terminator), with no corresponding tag"))
        }
        let willClose = self.awaitingBody.removeLast()
        guard willClose.parent.matches(terminator: terminator) else {
            throw LeafError(.unknownError("\(name): unable to match \(willClose.parent) with \(terminator)"))
        }

        // closed body
        let newSyntax = try willClose.parent.makeSyntax(body: willClose.body)

        func append(_ syntax: Syntax) {
            if var newTail = self.awaitingBody.last {
                 newTail.body.append(syntax)
                 self.awaitingBody.removeLast()
                 self.awaitingBody.append(newTail)
                 // if the new syntax is a conditional, it may need to be attached
                 // to the last parsed conditional
             } else {
                 self.finished.append(syntax)
             }
        }

        if case .conditional(let new) = newSyntax {
            guard let conditional = new.chain.first else {
                throw LeafError(.unknownError("Malformed syntax block"))
            }
            switch conditional.0.naturalType {
                // a new if, never attaches to a previous
                case .if:
                    append(newSyntax)
                case .elseif, .else:
                    let aW = self.awaitingBody.last?.body
                    let previousBlock: Syntax?
                    switch aW {
                    case .none: previousBlock = self.finished.last
                    case .some(let b): previousBlock = b.last
                    }
                    guard let existingConditional = previousBlock,
                        case .conditional(var tail) = existingConditional
                    else {
                        throw LeafError(.unknownError("Can't attach \(conditional.0) to \(previousBlock?.description ?? "empty AST")"))
                    }
                    try tail.attach(new)
                    switch aW {
                    case .none:
                        self.finished[self.finished.index(before: self.finished.endIndex)] = .conditional(tail)
                    case .some(_):
                        self.awaitingBody[self.awaitingBody.index(before: self.awaitingBody.endIndex)].body.removeLast()
                        self.awaitingBody[self.awaitingBody.index(before: self.awaitingBody.endIndex)].body.append(.conditional(tail))
                    }
            }
        } else {
            append(newSyntax)
        }
    }

    // once a tag has started, it is terminated by `.raw`, `.parameters`, or `.tagBodyIndicator`
    // ------
    // A tag MAY NOT expect any body given a certain number of parameters, and this will blindly
    // consume colons in that event when it's not inteded; eg `#(variable):` CANNOT expect a body
    // and thus the colon should be assumed to be raw. TagDeclaration should first validate expected
    // parameter pattern against the actual named tag before assuming expectsBody to be true OR false
    private mutating func readTagDeclaration() throws -> TagDeclaration {
        // consume tag indicator
        guard let first = self.read(), first == .tagIndicator else {
            throw LeafError(.unknownError("expected .tagIndicator(\(LeafConfiguration.tagIndicator))"))
        }
        // a tag should ALWAYS follow a tag indicator
        guard let tag = self.read(), case .tag(let name) = tag else {
            throw LeafError(.unknownError("expected tag name following a tag indicator"))
        }

        // if no further, then we've ended w/ a tag
        guard let next = self.peek() else {
            return TagDeclaration(name: name, parameters: nil, expectsBody: false)
        }

        // following a tag can be,
        // .raw - tag is complete
        // .tagBodyIndicator - ready to read body
        // .parametersStart - start parameters
        // .tagIndicator - a new tag started
        switch next {
            // MARK: no param, no body case should be re-evaluated?
            // we require that tags have parameter notation INSIDE parameters even when they're
            // empty - eg `#tag(anotherTag())` - so `#anotherTag()` should be required, not
            // `#anotherTag`. If that's enforced, the only acceptable non-decaying noparam/nobody
            // use would be `#endTag` to close a body
            case .raw,
                 .tagIndicator:
                // a basic tag, something like `#date` w/ no params, and no body
                return TagDeclaration(name: name, parameters: nil, expectsBody: false)
            // MARK: anonymous tBI (`#:`) probably should decay tagIndicator to raw?
            case .tagBodyIndicator:
                if !name.isEmpty {
                    self.pop()
                } else {
                    self.replace(with: .raw(":"))
                }
                return TagDeclaration(name: name, parameters: nil, expectsBody: true)
            case .parametersStart:
                // An anonymous function `#(variable):` is incapable of having a body, so change tBI to raw
                // Can be more intelligent - there should be observer methods on tag declarations to
                // allow checking if a certain parameter set requires a body or not
                let params = try self.readParameters()
                var expectsBody = false
                if self.peek() == .tagBodyIndicator {
                    if name.isEmpty {
                        self.replace(with: .raw(":"))
                    } else {
                        self.pop()
                        expectsBody = true
                    }
                }
                return TagDeclaration(name: name, parameters: params, expectsBody: expectsBody)
            default:
                throw LeafError(.unknownError("found unexpected token " + next.description))
        }
    }

    private mutating func readParameters() throws -> [ParameterDeclaration] {
        // ensure open parameters
        guard self.read() == .parametersStart else {
            throw LeafError(.unknownError("expected parameters start"))
        }

        var group = [ParameterDeclaration]()
        var paramsList = [ParameterDeclaration]()
      
        func dump() throws {
            defer { group = [] }
            if group.isEmpty {
                return
            }
            group.evaluate()
            if group.count > 1 {
                paramsList.append(.expression(group))
            } else {
                guard let first = group.first else {
                    // It's better to handle this case as well, even though logically it might never happen
                    // since you're checking if group.isEmpty before.
                    throw LeafError(.unknownError("Found nil while iterating through params"))
                }
                paramsList.append(first)
            }
        }

        outer: while let next = peek() {
            switch next {
                case .parametersStart:
                    // found a nested () that we will group together into
                    // an expression, ie: #if(foo == (bar + car))
                    let params = try self.readParameters()
                    // parameter tags not permitted to have bodies
                    if params.count > 1 {
                        group.append(.expression(params))
                    } else {
                      guard let firstParam = params.first else {
                        throw LeafError(.unknownError("Found nil while iterating through params"))
                      }
                      group.append(firstParam)
                    }
                case .parameter(let p):
                    self.pop()
                    switch p {
                        case .tag(let name):
                            guard self.peek() == .parametersStart else {
                                throw LeafError(.unknownError("tags in parameter list MUST declare parameter list"))
                            }
                            let params = try self.readParameters()
                            // parameter tags not permitted to have bodies
                            group.append(.tag(.init(name: name, params: params, body: nil)))
                        default:
                            group.append(.parameter(p))
                    }
                case .parametersEnd:
                    self.pop()
                    try dump()
                    break outer
                case .parameterDelimiter:
                    self.pop()
                    try dump()
                case .whitespace:
                    self.pop()
                    continue
                default:
                    break outer
            }
        }

        paramsList.evaluate()
        return paramsList
    }

    private mutating func collectRaw() throws -> ByteBuffer {
        var raw = ByteBuffer()
        while let peek = self.peek(), case .raw(let val) = peek {
            self.pop()
            raw.writeString(val)
        }
        return raw
    }

    private func peek() -> LeafToken? {
        guard self.offset < self.tokens.count else {
            return nil
        }
        return self.tokens[self.offset]
    }

    private mutating func pop() {
        self.offset += 1
    }

    private mutating func replace(at offset: Int = 0, with new: LeafToken) {
        self.tokens[self.offset + offset] = new
    }

    private mutating func read() -> LeafToken? {
        guard self.offset < self.tokens.count,
              let val = self.peek()
        else {
            return nil
        }
        self.pop()
        return val
    }

    private mutating func readWhile(_ check: (LeafToken) -> Bool) -> [LeafToken]? {
        guard self.offset < self.tokens.count else {
            return nil
        }
        var matched = [LeafToken]()
        while let next = self.peek(), check(next) {
            matched.append(next)
        }
        return matched.isEmpty ? nil : matched
    }
    
    private struct OpenContext {
        let parent: TagDeclaration
        var body: [Syntax] = []
        init(_ parent: TagDeclaration) {
            self.parent = parent
        }
    }

    private struct TagDeclaration {
        let name: String
        let parameters: [ParameterDeclaration]?
        let expectsBody: Bool
        
        func makeSyntax(body: [Syntax]) throws -> Syntax {
            let params = self.parameters ?? []

            switch self.name {
                case let n where n.starts(with: "end"):
                    throw LeafError(.unknownError("unable to convert terminator to syntax"))
                case "":
                    guard params.count == 1 else {
                        throw LeafError(.unknownError("only single parameter support, should be broken earlier"))
                    }
                    switch params[0] {
                        case .parameter(let p):
                            switch p {
                                case .variable(_):
                                    return .expression([params[0]])
                                case .constant(let c):
                                    var buffer = ByteBuffer()
                                    buffer.writeString(c.description)
                                    return .raw(buffer)
                                case .stringLiteral(let st):
                                    var buffer = ByteBuffer()
                                    buffer.writeString(st)
                                    return .raw(buffer)
                                case .keyword(let kw) :
                                    guard kw.isBooleanValued else { fallthrough }
                                    var buffer = ByteBuffer()
                                    buffer.writeString(kw.rawValue)
                                    return .raw(buffer)
                                default:
                                    throw LeafError(.unknownError("unsupported parameter \(p)"))
                            }
                        case .expression(let e):
                            return .expression(e)
                        case .tag(let t):
                            return .custom(t)
                    }
                case "if":
                    return .conditional(.init(.if(params), body: body))
                case "elseif":
                    return .conditional(.init(.elseif(params), body: body))
                case "else":
                    guard params.count == 0 else {
                        throw LeafError(.unknownError("else does not accept params"))
                    }
                    return .conditional(.init(.else, body: body))
                case "for":
                    return try .loop(.init(params, body: body))
                case "export":
                    return try .export(.init(params, body: body))
                case "extend":
                    return try .extend(.init(params, body: body))
                case "with":
                    return try .with(.init(params, body: body))
                case "import":
                    guard body.isEmpty else {
                        throw LeafError(.unknownError("import does not accept a body"))
                    }
                    return try .import(.init(params))
                default:
                    return .custom(.init(name: self.name, params: params, body: body))
            }
        }

        var isTerminator: Bool {
            switch self.name {
            case let x where x.starts(with: "end"):
                return true
            // dual function
            case "elseif", "else":
                return true
            default:
                return false
            }
        }

        func matches(terminator: TagDeclaration) -> Bool {
            guard terminator.isTerminator else {
                return false
            }
            switch terminator.name {
            // if can NOT be a terminator
            case "else", "elseif":
                // else and elseif can only match to if or elseif
                return self.name == "if" || self.name == "elseif"
            case "endif":
                return self.name == "if" || self.name == "elseif" || self.name == "else"
            default:
                return terminator.name == "end" + self.name
            }
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafSerialize/Dictionary+LeafData.swift ###
public extension Dictionary where Key == String, Value == LeafData {
    subscript(keyPath keyPath: String) -> LeafData? {
        let comps = keyPath.split(separator: ".").map(String.init)
        return self[keyPath: comps]
    }

    subscript(keyPath comps: [String]) -> LeafData? {
        if comps.isEmpty {
            return nil
        } else if comps.count == 1 {
            return self[comps[0]]
        }

        var comps = comps
        let key = comps.removeFirst()
        guard let val = self[key]?.dictionary else {
            return nil
        }
        return val[keyPath: comps]
    }
}

### File: leaf-kit/Sources/LeafKit/LeafSerialize/LeafContext.swift ###
public struct LeafContext {
    public let parameters: [LeafData]
    public let data: [String: LeafData]
    public let body: [Syntax]?
    public let userInfo: [AnyHashable: Any]

    init(
        parameters: [LeafData],
        data: [String: LeafData],
        body: [Syntax]?,
        userInfo: [AnyHashable: Any]
    ) throws {
        self.parameters = parameters
        self.data = data
        self.body = body
        self.userInfo = userInfo
    }

    /// Throws an error if the parameter count does not equal the supplied number `n`.
    public func requireParameterCount(_ n: Int) throws {
        guard self.parameters.count == n else {
            throw LeafError(.unknownError("Invalid parameter count: \(self.parameters.count)/\(n)"))
        }
    }

    /// Throws an error if this tag does not include a body.
    public func requireBody() throws -> [Syntax] {
        guard let body, !body.isEmpty else {
            throw LeafError(.unknownError("Missing body"))
        }

        return body
    }

    /// Throws an error if this tag includes a body.
    public func requireNoBody() throws {
        if let body, !body.isEmpty {
            throw LeafError(.unknownError("Extraneous body"))
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafSerialize/LeafSerializer.swift ###
import NIOCore

struct LeafSerializer {
    // MARK: - Internal Only
    
    init(
        ast: [Syntax],
        tags: [String: any LeafTag] = defaultTags,
        userInfo: [AnyHashable: Any] = [:],
        ignoreUnfoundImports: Bool
        
    ) {
        self.ast = ast
        self.offset = 0
        self.buffer = ByteBufferAllocator().buffer(capacity: 0)
        self.tags = tags
        self.userInfo = userInfo
        self.ignoreUnfoundImports = ignoreUnfoundImports
    }
    
    mutating func serialize(
        context data: [String: LeafData]
    ) throws -> ByteBuffer {
        self.offset = 0
        while let next = self.peek() {
            self.pop()
            try self.serialize(next, context: data)
        }
        return self.buffer
    }
    
    // MARK: - Private Only
    
    private let ast: [Syntax]
    private var offset: Int
    private var buffer: ByteBuffer
    private let tags: [String: any LeafTag]
    private let userInfo: [AnyHashable: Any]
    private let ignoreUnfoundImports: Bool

    private mutating func serialize(_ syntax: Syntax, context data: [String: LeafData]) throws {
        switch syntax {
            case .raw(var byteBuffer): self.buffer.writeBuffer(&byteBuffer)
            case .custom(let custom):  try self.serialize(custom, context: data)
            case .conditional(let c):  try self.serialize(c, context: data)
            case .loop(let loop):      try self.serialize(loop, context: data)
            case .with(let with):      try self.serialize(with, context: data)
            case .expression(let exp): try self.serialize(expression: exp, context: data)
            case .import:
                if (self.ignoreUnfoundImports) {
                    break
                } else {
                    fallthrough
                }
            case .extend, .export:
                throw LeafError(.unknownError("\(syntax) should have been resolved BEFORE serialization"))
        }
    }

    private mutating func serialize(expression: [ParameterDeclaration], context data: [String: LeafData]) throws {
        let resolved = try self.resolve(parameters: [.expression(expression)], context: data)
        guard resolved.count == 1, let leafData = resolved.first else {
            throw LeafError(.unknownError("expressions should resolve to single value"))
        }
        try? leafData.htmlEscaped().serialize(buffer: &self.buffer)
    }

    private mutating func serialize(body: [Syntax], context data: [String: LeafData]) throws {
        try body.forEach { try self.serialize($0, context: data) }
    }

    private mutating func serialize(_ conditional: Syntax.Conditional, context data: [String: LeafData]) throws {
        evaluate:
        for block in conditional.chain {
            let evaluated = try self.resolveAtomic(block.condition.expression(), context: data)
            guard (evaluated.bool ?? false) || (!evaluated.isNil && evaluated.celf != .bool) else {
                continue
            }
            try self.serialize(body: block.body, context: data)
            break evaluate
        }
    }

    private mutating func serialize(_ tag: Syntax.CustomTagDeclaration, context data: [String: LeafData]) throws {
        let sub = try LeafContext(
            parameters: self.resolve(parameters: tag.params, context: data),
            data: data,
            body: tag.body,
            userInfo: self.userInfo
        )

        guard let foundTag = self.tags[tag.name] else {
            try? LeafData("#\(tag.name)").serialize(buffer: &self.buffer)
            return
        }

        let leafData: LeafData

        if foundTag is any UnsafeUnescapedLeafTag {
            leafData = try foundTag.render(sub)
        } else {
            leafData = try foundTag.render(sub).htmlEscaped()
        }

        try? leafData.serialize(buffer: &self.buffer)
    }

    private mutating func serialize(_ with: Syntax.With, context data: [String: LeafData]) throws {
        let resolved = try self.resolve(parameters: [.expression(with.context)], context: data)
        guard resolved.count == 1,
            let dict = resolved[0].dictionary
        else {
            throw LeafError(.unknownError("expressions should resolve to a single dictionary value"))
        }

        try? self.serialize(body: with.body, context: dict)
    }

    private mutating func serialize(_ loop: Syntax.Loop, context data: [String: LeafData]) throws {
        let finalData: [String: LeafData]
        let pathComponents = loop.array.split(separator: ".")

        if pathComponents.count > 1 {
            finalData = try pathComponents[0..<(pathComponents.count - 1)].enumerated()
                .reduce(data) { (innerData, pathContext) -> [String: LeafData] in
                    let key = String(pathContext.element)

                    guard let nextData = innerData[key]?.dictionary else {
                        let currentPath = pathComponents[0...pathContext.offset].joined(separator: ".")
                        throw LeafError(.unknownError("expected dictionary at key: \(currentPath)"))
                    }

                    return nextData
                }
        } else {
            finalData = data
        }

        guard let array = finalData[String(pathComponents.last!)]?.array else {
            throw LeafError(.unknownError("expected array at key: \(loop.array)"))
        }

        for (idx, item) in array.enumerated() {
            var innerContext = data

            innerContext["isFirst"] = .bool(idx == array.startIndex)
            innerContext["isLast"] = .bool(idx == array.index(before: array.endIndex))
            innerContext[loop.index] = .int(idx)
            innerContext[loop.item] = item

            var serializer = LeafSerializer(
                ast: loop.body,
                tags: self.tags,
                userInfo: self.userInfo,
                ignoreUnfoundImports: self.ignoreUnfoundImports
            )
            var loopBody = try serializer.serialize(context: innerContext)
            self.buffer.writeBuffer(&loopBody)
        }
    }

    private func resolve(parameters: [ParameterDeclaration], context data: [String: LeafData]) throws -> [LeafData] {
        let resolver = ParameterResolver(
            params: parameters,
            data: data,
            tags: self.tags,
            userInfo: self.userInfo
        )
        return try resolver.resolve().map { $0.result }
    }
    
    // Directive resolver for a [ParameterDeclaration] where only one parameter is allowed that must resolve to a single value
    private func resolveAtomic(_ parameters: [ParameterDeclaration], context data: [String: LeafData]) throws -> LeafData {
        guard parameters.count == 1 else {
            if parameters.isEmpty {
                throw LeafError(.unknownError("Parameter statement can't be empty"))
            } else {
                throw LeafError(.unknownError("Parameter statement must hold a single value"))
            }
        }
        return try self.resolve(parameters: parameters, context: data).first ?? .trueNil
    }

    private func peek() -> Syntax? {
        guard self.offset < self.ast.count else {
            return nil
        }
        return self.ast[self.offset]
    }

    private mutating func pop() {
        self.offset += 1
    }
}

### File: leaf-kit/Sources/LeafKit/LeafSerialize/ParameterResolver.swift ###
import Foundation

extension ParameterDeclaration {
    func `operator`() -> LeafOperator? {
        guard case .parameter(.operator(let o)) = self else {
            return nil
        }
        return o
    }
}

struct ParameterResolver {
    // MARK: - Internal Only
    
    let params: [ParameterDeclaration]
    let data: [String: LeafData]
    let tags: [String: any LeafTag]
    let userInfo: [AnyHashable: Any]

    func resolve() throws -> [ResolvedParameter] {
        try self.params.map(resolve)
    }

    struct ResolvedParameter {
        let param: ParameterDeclaration
        let result: LeafData
    }
    
    // MARK: - Private Only

    private func resolve(_ param: ParameterDeclaration) throws -> ResolvedParameter {
        let result: LeafData
        switch param {
            case .expression(let e):
                result = try self.resolve(expression: e)
            case .parameter(let p):
                result = try self.resolve(param: p)
            case .tag(let t):
                let resolver = ParameterResolver(
                    params: t.params,
                    data: self.data,
                    tags: self.tags,
                    userInfo: self.userInfo
                )
                let ctx = try LeafContext(
                    parameters: resolver.resolve().map { $0.result },
                    data: data,
                    body: t.body,
                    userInfo: self.userInfo
                )
                result = try self.tags[t.name]?.render(ctx) ?? .trueNil
        }
        return .init(param: param, result: result)
    }

    private func resolve(param: Parameter) throws -> LeafData {
        switch param {
        case .constant(let c):
            switch c {
            case .double(let d):
                LeafData(.double(d))
            case .int(let d):
                LeafData(.int(d))
            }
        case .stringLiteral(let s):
            .init(.string(s))
        case .variable(let v):
            self.data[keyPath: v] ?? .trueNil
        case .keyword(let k):
            switch k {
                case .this: .init(.dictionary(self.data))
                case .nil: .trueNil
                case .true, .yes: .init(.bool(true))
                case .false, .no: .init(.bool(false))
                default: throw LeafError(.unknownError("unexpected keyword"))
            }
        // these should all have been removed in processing
        case .tag:
            throw LeafError(.unknownError("unexpected tag"))
        case .operator:
            throw LeafError(.unknownError("unexpected operator"))
        }
    }

    // #if(lowercase(first(name == "admin")) == "welcome")
    private func resolve(expression: [ParameterDeclaration]) throws -> LeafData {
        if expression.count == 1 {
            return try self.resolve(expression[0]).result
        } else if expression.count == 2 {
            if let lho = expression[0].operator() {
                let rhs = try self.resolve(expression[1]).result
                return try self.resolve(op: lho, rhs: rhs)
            } else if let _ = expression[1].operator() {
                throw LeafError(.unknownError("right hand expressions not currently supported"))
            } else {
                throw LeafError(.unknownError("two part expression expected to include at least one operator"))
            }
        } else if expression.count == 3 {
            // file == name + ".jpg"
            // should resolve to:
            // param(file) == expression(name + ".jpg")
            // based on priorities in such a way that each expression
            // is 3 variables, lhs, functor, rhs
            guard expression.count == 3 else {
                throw LeafError(.unknownError("multiple expressions not currently supported: \(expression)"))
            }
            let lhs = try self.resolve(expression[0]).result
            let functor = expression[1]
            let rhs = try self.resolve(expression[2]).result
            guard case .parameter(let p) = functor else {
                throw LeafError(.unknownError("expected keyword or operator"))
            }
            switch p {
            case .keyword(let k):
                return try self.resolve(lhs: lhs, key: k, rhs: rhs)
            case .operator(let o):
                return try self.resolve(lhs: lhs, op: o, rhs: rhs)
            default:
                throw LeafError(.unknownError("unexpected parameter: \(p)"))
            }
        } else {
            throw LeafError(.unknownError("unsupported expression, expected 2 or 3 components: \(expression)"))
        }
    }

    private func resolve(op: LeafOperator, rhs: LeafData) throws -> LeafData {
        switch op {
        case .not:
            let result = rhs.bool ?? !rhs.isNil
            return .bool(!result)
        case .minus:
            return try self.resolve(lhs: -1, op: .multiply, rhs: rhs)
        default:
            throw LeafError(.unknownError("unexpected left hand operator not supported: \(op)"))
        }
    }

    private func resolve(lhs: LeafData, op: LeafOperator, rhs: LeafData) throws -> LeafData {
        switch op {
        case .not:
            throw LeafError(.unknownError("single expression operator"))
        case .and:
            let lhs = lhs.bool ?? !lhs.isNil
            let rhs = rhs.bool ?? !rhs.isNil
            return .bool(lhs && rhs)
        case .or:
            let lhs = lhs.bool ?? !lhs.isNil
            let rhs = rhs.bool ?? !rhs.isNil
            return .bool(lhs || rhs)
        case .equal:
            return .bool(lhs == rhs)
        case .unequal:
            return .bool(lhs != rhs)
        case .lesser:
            guard let lhs = lhs.string, let rhs = rhs.string else { return LeafData.trueNil }
            if let lhs = Double(lhs), let rhs = Double(rhs) {
                return .bool(lhs < rhs)
            } else {
                return .bool(lhs < rhs)
            }
        case .lesserOrEqual:
            guard let lhs = lhs.string, let rhs = rhs.string else { return LeafData.trueNil }
            if let lhs = Double(lhs), let rhs = Double(rhs) {
                return .bool(lhs <= rhs)
            } else {
                return .bool(lhs <= rhs)
            }
        case .greater:
            guard let lhs = lhs.string, let rhs = rhs.string else { return LeafData.trueNil }
            if let lhs = Double(lhs), let rhs = Double(rhs) {
                return .bool(lhs > rhs)
            } else {
                return .bool(lhs > rhs)
            }
        case .greaterOrEqual:
            guard let lhs = lhs.string, let rhs = rhs.string else { return LeafData.trueNil }
            if let lhs = Double(lhs), let rhs = Double(rhs) {
                return .init(.bool(lhs >= rhs))
            } else {
                return .init(.bool(lhs >= rhs))
            }
        case .plus:
            return try self.plus(lhs: lhs, rhs: rhs)
        case .minus:
            return try self.minus(lhs: lhs, rhs: rhs)
        case .multiply:
            return try self.multiply(lhs: lhs, rhs: rhs)
        case .divide:
            return try self.divide(lhs: lhs, rhs: rhs)
        case .modulo:
            return try self.modulo(lhs: lhs, rhs: rhs)
        case .assignment: throw LeafError(.unknownError("Future feature"))
        case .nilCoalesce: throw LeafError(.unknownError("Future feature"))
        case .evaluate: throw LeafError(.unknownError("Future feature"))
        case .scopeRoot: throw LeafError(.unknownError("Future feature"))
        case .scopeMember: throw LeafError(.unknownError("Future feature"))
        case .subOpen: throw LeafError(.unknownError("Future feature"))
        case .subClose: throw LeafError(.unknownError("Future feature"))
        }
    }

    private func plus(lhs: LeafData, rhs: LeafData) throws -> LeafData {
        switch lhs.storage {
        case .array(let arr):
            let rhs = rhs.array ?? []
            return .array(arr + rhs)
        case .data(let data):
            let rhs = rhs.data ?? Data()
            return .data(data + rhs)
        case .string(let s):
            let rhs = rhs.string ?? ""
            return .string(s + rhs)
        case .int(let i):
            // if either is double, be double
            if case .double(let d) = rhs.storage {
                let sum = Double(i) + d
                return .double(sum)
            } else {
                let rhs = rhs.int ?? 0
                let added = i.addingReportingOverflow(rhs)
                guard !added.overflow else {
                    throw LeafError(.unknownError("Integer overflow"))
                }
                return .int(added.partialValue)
            }
        case .double(let d):
            let rhs = rhs.double ?? 0
            return .double(d + rhs)
        case .dictionary(let lhs):
            var rhs = rhs.dictionary ?? [:]
            lhs.forEach { key, val in
                rhs[key] = val
            }
            return .init(.dictionary(rhs))

        case .optional(_, _):
            throw LeafError(.unknownError("Optional unwrapping not possible yet"))
        case .bool(let b):
            throw LeafError(.unknownError("unable to concatenate bool `\(b)` with `\(rhs)', maybe you meant &&"))
        }
    }

    private func minus(lhs: LeafData, rhs: LeafData) throws -> LeafData {
        switch lhs.storage {
        case .optional(_, _):
            throw LeafError(.unknownError("Optional unwrapping not possible yet"))
        case .array(let arr):
            let rhs = rhs.array ?? []
            let new = arr.filter { !rhs.contains($0) }
            return .array(new)
        case .int(let i):
            // if either is double, be double
            if case .double(let d) = rhs.storage {
                let oppositeOfSum = Double(i) - d
                return .double(oppositeOfSum)
            } else {
                let rhs = rhs.int ?? 0
                let subtracted = i.subtractingReportingOverflow(rhs)
                guard !subtracted.overflow else {
                    throw LeafError(.unknownError("Integer underflow"))
                }
                return .int(subtracted.partialValue)
            }
        case .double(let d):
            let rhs = rhs.double ?? 0
            return .double(d - rhs)
        case .data, .string, .dictionary, .bool:
            throw LeafError(.unknownError("unable to subtract from \(lhs)"))
        }
    }

    private func multiply(lhs: LeafData, rhs: LeafData) throws -> LeafData {
        switch lhs.storage {
        case .optional(_, _):
            throw LeafError(.unknownError("Optional unwrapping not possible yet"))
        case .int(let i):
            // if either is double, be double
            if case .double(let d) = rhs.storage {
                let product = Double(i) * d
                return .double(product)
            } else {
                let rhs = rhs.int ?? 0
                return .int(i * rhs)
            }
        case .double(let d):
            let rhs = rhs.double ?? 0
            return .double(d * rhs)
        case .data, .array, .string, .dictionary, .bool:
            throw LeafError(.unknownError("unable to multiply this type `\(lhs)`"))
        }
    }

    private func divide(lhs: LeafData, rhs: LeafData) throws -> LeafData {
        switch lhs.storage {
        case .optional(_, _):
            throw LeafError(.unknownError("Optional unwrapping not possible yet"))
        case .int(let i):
            // if either is double, be double
            if case .double(let d) = rhs.storage {
                let product = Double(i) / d
                return .double(product)
            } else {
                let rhs = rhs.int ?? 0
                return .int(i / rhs)
            }
        case .double(let d):
            let rhs = rhs.double ?? 0
            return .double(d / rhs)
        case .data, .array, .string, .dictionary, .bool:
            throw LeafError(.unknownError("unable to divide this type `\(lhs)`"))
        }
    }
    
    private func modulo(lhs: LeafData, rhs: LeafData) throws -> LeafData {
        switch lhs.storage {
        case .optional(_, _):
            throw LeafError(.unknownError("Optional unwrapping not possible yet"))
        case .int(let i):
            // if either is double, be double
            if case .double(let d) = rhs.storage {
                let product = Double(i).truncatingRemainder(dividingBy: d)
                return .double(product)
            } else {
                let rhs = rhs.int ?? 0
                return .int(i % rhs)
            }
        case .double(let d):
            let rhs = rhs.double ?? 0
            return .double(d.truncatingRemainder(dividingBy: rhs))
        case .data, .array, .string, .dictionary, .bool:
            throw LeafError(.unknownError("unable to apply modulo on this type `\(lhs)`"))
        }
    }

    private func resolve(lhs: LeafData, key: LeafKeyword, rhs: LeafData) throws -> LeafData {
        switch key {
        case .in:
            let arr = rhs.array ?? []
            return .init(.bool(arr.contains(lhs)))
        default:
            return .trueNil
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafSource/LeafSource.swift ###
public import struct NIOCore.ByteBuffer
public import protocol NIOCore.EventLoop
public import class NIOCore.EventLoopFuture

/// Public protocol to adhere to in order to provide template source originators to `LeafRenderer`
public protocol LeafSource {
    /// Given a path name, return an EventLoopFuture holding a ByteBuffer
    /// - Parameters:
    ///   - template: Relative template name (eg: `"path/to/template"`)
    ///   - escape: If the adherent represents a filesystem or something scoped that enforces
    ///             a concept of directories and sandboxing, whether to allow escaping the view directory
    ///   - eventLoop: `EventLoop` on which to perform file access
    /// - Returns: A succeeded `EventLoopFuture` holding a `ByteBuffer` with the raw
    ///            template, or an appropriate failed state ELFuture (not found, illegal access, etc)
    func file(
        template: String,
        escape: Bool,
        on eventLoop: any EventLoop
    ) throws -> EventLoopFuture<ByteBuffer>
}

### File: leaf-kit/Sources/LeafKit/LeafSource/LeafSources.swift ###
import NIOCore
import NIOConcurrencyHelpers

/// An opaque object holding named `LeafSource` adherants specifying a default search order.
///
/// This object is `public` solely for convenience in reading the currently configured state.
///
/// Once registered, the `LeafSource` objects can not be accessed or modified - they *must* be
/// fully configured prior to registering with the instance of `LeafSources`
/// - `LeafSource` objects are registered with an instance of this class - this should *only* be done
///     prior to use by `LeafRenderer`.
/// - `.all` provides a `Set` of the `String`keys for all sources registered with the instance
/// - `.searchOrder` provides the keys of sources that an unspecified template request will search.
public final class LeafSources: Sendable {
    // MARK: - Public
    
    /// All available `LeafSource`s of templates
    public var all: Set<String> {
        self.lock.withLock { .init(self.sources.keys) }
    }
    /// Configured default implicit search order of `LeafSource`'s
    public var searchOrder: [String] {
        self.lock.withLock { self.order }
    }

    public init() {
        self.sources = [:]
        self.order = []
    }
    
    /// Register a `LeafSource` as `key`
    /// - Parameters:
    ///   - key: Name for the source; at most one may be registered without a name
    ///   - source: A fully configured `LeafSource` object
    ///   - searchable: Whether the source should be added to the default search path
    /// - Throws: Attempting to overwrite a previously named source is not permitted
    public func register(
        source key: String = "default",
        using source: any LeafSource,
        searchable: Bool = true
    ) throws {
        try self.lock.withLock {
            guard !self.sources.keys.contains(key) else {
                throw LeafError(.unknownError("Can't replace source at \(key)"))
            }
            self.sources[key] = source
            if searchable {
                self.order.append(key)
            }
        }
    }
    
    /// Convenience for initializing a `LeafSources` object with a single `LeafSource`
    /// - Parameter source: A fully configured `LeafSource`
    /// - Returns: Configured `LeafSource` instance
    public static func singleSource(_ source: any LeafSource) -> LeafSources {
        let sources = LeafSources()
        try! sources.register(using: source)
        return sources
    }
    
    // MARK: - Internal Only

    // Note: nonisolated(unsafe) is safe because these are protected by the lock
    private(set) nonisolated(unsafe) var sources: [String: any LeafSource]
    private nonisolated(unsafe) var order: [String]
    private let lock: NIOLock = .init()
    
    /// Locate a template from the sources; if a specific source is named, only try to read from it. Otherwise, use the specified search order
    func find(template: String, in source: String? = nil, on eventLoop: any EventLoop) throws -> EventLoopFuture<(String, ByteBuffer)> {
        var keys: [String]
        
        switch source {
        case .none:
            keys = self.searchOrder
        case .some(let source):
            if all.contains(source) {
                keys = [source]
            } else {
                throw LeafError(.illegalAccess("Invalid source \(source) specified"))
            }
        }
        guard !keys.isEmpty else {
            throw LeafError(.illegalAccess("No searchable sources exist"))
        }

        return self.searchSources(t: template, on: eventLoop, s: keys)
    }
    
    private func searchSources(t: String, on eL: any EventLoop, s: [String]) -> EventLoopFuture<(String, ByteBuffer)> {
        guard !s.isEmpty else {
            return eL.makeFailedFuture(LeafError(.noTemplateExists(t)))
        }
        var more = s
        let key = more.removeFirst()
        let source = self.lock.withLock {
            self.sources[key]!
        }

        do {
            let file = try source.file(template: t, escape: true, on: eL)
            // Hit the file - return the combined tuple
            return eL.makeSucceededFuture(key).and(file).flatMapError { [more] _ in
                // Or move onto the next one if this source can't get the file
                return self.searchSources(t: t, on: eL, s: more)
            }
        } catch {
            // If the thrown error is illegal access, fail immediately
            if let e = error as? LeafError,
               case .illegalAccess(_) = e.reason
            {
                return eL.makeFailedFuture(e)
            } else {
                // Or move onto the next one
                return self.searchSources(t: t, on: eL, s: more)
            }
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafSource/NIOLeafFiles.swift ###
import Foundation
public import struct NIOCore.ByteBuffer
public import protocol NIOCore.EventLoop
public import class NIOCore.EventLoopFuture
import _NIOFileSystem
public import struct NIOPosix.NonBlockingFileIO

/// Reference and default implementation of `LeafSource` adhering object that provides a non-blocking
/// file reader for `LeafRenderer`
///
/// Default initializer will
public struct NIOLeafFiles: LeafSource, Sendable {
    // MARK: - Public
    
    /// Various options for configuring an instance of `NIOLeafFiles`
    ///
    /// - `.requireExtensions` - When set, any template *must* have a file extension
    /// - `.onlyLeafExtensions` - When set, any template *must* use the configured extension
    /// - `.toSandbox` - When set, attempts to read files outside of the sandbox directory will error
    /// - `.toVisibleFiles` - When set, attempts to read files starting with `.` will error (or files
    ///                     inside a directory starting with `.`)
    ///
    /// A new `NIOLeafFiles` defaults to [.toSandbox, .toVisibleFiles, .requireExtensions]
    public struct Limit: OptionSet, Sendable {
        public let rawValue: Int

        public init(rawValue: Int) {
            self.rawValue = rawValue
        }
        
        /// Require any referenced file have an extension
        public static let requireExtensions = Limit(rawValue: 1 << 0)
        /// Require any referenced file end in `.leaf`
        public static let onlyLeafExtensions = Limit(rawValue: 1 << 1)
        /// Limit access to inside configured sandbox directory
        public static let toSandbox = Limit(rawValue: 1 << 2)
        /// Limit access to visible files/directories
        public static let toVisibleFiles = Limit(rawValue: 1 << 3)
        
        public static let `default`: Limit = [.toSandbox, .toVisibleFiles, .requireExtensions]
        public static let dirLimited: Limit = [.toSandbox, .toVisibleFiles]
    }
    
    /// Initialize `NIOLeafFiles` with a NIO file IO object, limit options, and sandbox/view dirs
    /// - Parameters:
    ///   - fileio: `NonBlockingFileIO` file object. This is no longer used but must still be passed.
    ///   - limits: Options for constraining which files may be read - see `NIOLeafFiles.Limit`
    ///   - sandboxDirectory: Full path of the lowest directory which may be escaped to
    ///   - viewDirectory: Full path of the default directory templates are relative to
    ///   - defaultExtension: The default extension inferred files will have (defaults to `leaf`)
    ///
    /// `viewDirectory` must be contained within (or overlap) `sandboxDirectory`
    public init(
        fileio _: NonBlockingFileIO,
        limits: Limit = .default,
        sandboxDirectory: String = "/",
        viewDirectory: String = "/",
        defaultExtension: String = "leaf"
    ) {
        self.limits = limits
        self.extension = defaultExtension
        let sD = URL(fileURLWithPath: sandboxDirectory, isDirectory: true).standardized.path.appending("/")
        let vD = URL(fileURLWithPath: viewDirectory, isDirectory: true).standardized.path.appending("/")
        // Ensure provided sandboxDir is directly reachable from viewDir, otherwise only use viewDir
        assert(vD.starts(with: sD), "View directory must be inside sandbox directory")
        self.sandbox = vD.starts(with: sD) ? sD : vD
        self.viewRelative = String(vD.dropFirst(sD.count))
    }

    /// Conformance to `LeafSource` to allow `LeafRenderer` to request a template.
    /// - Parameters:
    ///   - template: Relative template name (eg: `"path/to/template"`)
    ///   - escape: If the adherent represents a filesystem or something scoped that enforces
    ///             a concept of directories and sandboxing, whether to allow escaping the view directory
    ///   - eventLoop: `EventLoop` on which to perform file access
    /// - Returns: A succeeded `EventLoopFuture` holding a `ByteBuffer` with the raw
    ///            template, or an appropriate failed state ELFuture (not found, illegal access, etc)
    public func file(template: String, escape: Bool = false, on eventLoop: any EventLoop) throws -> EventLoopFuture<ByteBuffer> {
        var templateURL = URL(fileURLWithPath: self.sandbox)
            .appendingPathComponent(self.viewRelative, isDirectory: true)
            .appendingPathComponent(template, isDirectory: false)

        /// If default extension is enforced for template files, add it if it's not on the file, or if no extension present
        if self.limits.contains(.onlyLeafExtensions), templateURL.pathExtension != self.extension {
            templateURL.appendPathExtension(self.extension)
        } else if self.limits.contains(.requireExtensions), templateURL.pathExtension == "" {
            templateURL.appendPathExtension(self.extension)
        }

        let template = templateURL.standardized.path

        if !self.limits.isDisjoint(with: .dirLimited), [".", "/"].contains(template.first) {
            /// If sandboxing is enforced and the path contains a potential escaping path, look harder
            if self.limits.contains(.toVisibleFiles) {
                let protected = template.split(separator: "/")
                    .compactMap {
                        guard $0.count > 1, $0.first == ".", !$0.starts(with: "..") else { return nil }
                        return String($0)
                    }
                    .joined(separator: ",")
                if !protected.isEmpty {
                    throw LeafError(.illegalAccess("Attempted to access \(protected)"))
                }
            }
            
            if self.limits.contains(.toSandbox) {
                let limitedTo = escape ? self.sandbox : self.sandbox + self.viewRelative
                guard template.starts(with: limitedTo) else {
                    throw LeafError(.illegalAccess("Attempted to escape sandbox: \(template)"))
                }
            }
        }

        return self.read(path: template, on: eventLoop)
    }
    
    // MARK: - Internal/Private Only

    let limits: Limit
    let sandbox: String
    let viewRelative: String
    let `extension`: String
    
    /// Attempt to read a fully pathed template and return a ByteBuffer or fail
    private func read(path: String, on eventLoop: any EventLoop) -> EventLoopFuture<ByteBuffer> {
        eventLoop.makeFutureWithTask {
            do {
                return try await FileSystem.shared.withFileHandle(forReadingAt: .init(path)) { fh in
                    try await fh.readToEnd(maximumSizeAllowed: .gibibytes(2))
                }
            } catch let error as FileSystemError where error.code == .notFound {
                throw LeafError(.noTemplateExists(path))
            }
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafSyntax/LeafSyntax.swift ###
public import struct NIOCore.ByteBuffer

public indirect enum Syntax: Sendable {
    // MARK: .raw - Makeable, Entirely Readable
    case raw(ByteBuffer)
    // MARK: `case variable(Variable)` removed
    // MARK: .expression - Makeable, Entirely Readable
    case expression([ParameterDeclaration])
    // MARK: .custom - Unmakeable, Semi-Readable
    case custom(CustomTagDeclaration)
    // MARK: .with - Makeable, Entirely Readable
    case with(With)

    // MARK: .conditional - Makeable, Entirely Readable
    case conditional(Conditional)
    // MARK: .loop - Makeable, Semi-Readable
    case loop(Loop)
    // MARK: .`import` - Makeable, Readable (Pointlessly)
    case `import`(Import)
    // MARK: .extend - Makeable, Semi-Readable
    case extend(Extend)
    // MARK: .export - Makeable, Semi-Readable
    case export(Export)
}

public enum ConditionalSyntax: Sendable {
    case `if`([ParameterDeclaration])
    case `elseif`([ParameterDeclaration])
    case `else`
    
    func imports() -> Set<String> {
        switch self {
        case .if(let pDA), .elseif(let pDA):
            var imports = Set<String>()
            _ = pDA.map { imports.formUnion($0.imports()) }
            return imports
        default:
            return .init()
        }
    }
    
    func inlineImports(_ imports: [String : Syntax.Export]) -> ConditionalSyntax {
        switch self {
        case .else: self
        case .if(let pDA): .if(pDA.inlineImports(imports))
        case .elseif(let pDA): .elseif(pDA.inlineImports(imports))
        }
    }
    
    func expression() -> [ParameterDeclaration] {
        switch self {
        case .else: [.parameter(.keyword(.true))]
        case .elseif(let e): e
        case .if(let i): i
        }
    }
    
    var naturalType: ConditionalSyntax.NaturalType {
        switch self {
        case .if: .if
        case .elseif: .elseif
        case .else: .else
        }
    }
    
    enum NaturalType: Int, CustomStringConvertible {
        case `if` = 0
        case `elseif` = 1
        case `else` = 2
        
        var description: String {
            switch self {
            case .else: "else"
            case .elseif: "elseif"
            case .if: "if"
            }
        }
    }
}

// temporary addition
extension Syntax: BodiedSyntax  {
    func externals() -> Set<String> {
        switch self {
        case .conditional(let bS as any BodiedSyntax),
             .custom(let bS as any BodiedSyntax),
             .export(let bS as any BodiedSyntax),
             .extend(let bS as any BodiedSyntax),
             .with(let bS as any BodiedSyntax),
             .loop(let bS as any BodiedSyntax):
            bS.externals()
        default:
            .init()
        }
    }
    
    func imports() -> Set<String> {
        switch self {
        case .import(let i):
            .init(arrayLiteral: i.key)
        case .conditional(let bS as any BodiedSyntax),
             .custom(let bS as any BodiedSyntax),
             .export(let bS as any BodiedSyntax),
             .extend(let bS as any BodiedSyntax),
             .expression(let bS as any BodiedSyntax),
             .loop(let bS as any BodiedSyntax):
            bS.imports()
        // .variable, .raw
        default:
            .init()
        }
    }
    
    func inlineRefs(_ externals: [String: LeafAST], _ imports: [String: Export]) -> [Syntax] {
        if case .extend(let extend) = self, let context = extend.context {
            let inner = extend.inlineRefs(externals, imports)
            return [.with(.init(context: context, body: inner))]
        }
        var result = [Syntax]()
        switch self {
        case .import(let im):
            let ast = imports[im.key]?.body
            if let ast = ast {
                // If an export exists for this import, inline it
                ast.forEach { result += $0.inlineRefs(externals, imports) }
            } else {
                // Otherwise just keep itself
                result.append(self)
            }
        // Recursively inline single Syntaxes
        case .conditional(let bS as any BodiedSyntax),
             .custom(let bS as any BodiedSyntax),
             .export(let bS as any BodiedSyntax),
             .extend(let bS as any BodiedSyntax),
             .with(let bS as any BodiedSyntax),
             .loop(let bS as any BodiedSyntax):
            result += bS.inlineRefs(externals, imports)
        case .expression(let pDA):
            result.append(.expression(pDA.inlineImports(imports)))
        // .variable, .raw
        default:
            result.append(self)
        }
        return result
    }
}

protocol BodiedSyntax: Sendable {
    func externals() -> Set<String>
    func imports() -> Set<String>
    func inlineRefs(_ externals: [String: LeafAST], _ imports: [String: Syntax.Export]) -> [Syntax]
}

extension Array: BodiedSyntax where Element == Syntax {
    func externals() -> Set<String> {
        var result = Set<String>()
        _ = self.map { result.formUnion( $0.externals()) }
        return result
    }
    
    func imports() -> Set<String> {
        var result = Set<String>()
        _ = self.map { result.formUnion( $0.imports() ) }
        return result
    }

    func inlineRefs(_ externals: [String: LeafAST], _ imports: [String: Syntax.Export]) -> [Syntax] {
        var result = [Syntax]()
        _ = self.map { result.append(contentsOf: $0.inlineRefs(externals, imports)) }
        return result
    }
}

func indent(_ depth: Int) -> String {
    let block = "  "
    var buffer = ""
    for _ in 0..<depth {
        buffer += block
    }
    return buffer
}

extension Syntax {
    public struct Import: Sendable {
        public let key: String
        public init(_ params: [ParameterDeclaration]) throws {
            guard params.count == 1 else {
                throw LeafError(.unknownError("import only supports single param \(params)"))
            }
            guard case .parameter(let p) = params[0] else {
                throw LeafError(.unknownError("expected parameter"))
            }
            guard case .stringLiteral(let s) = p else {
                throw LeafError(.unknownError("import only supports string literals"))
            }
            self.key = s
        }

        func print(depth: Int) -> String {
            return indent(depth) + "import(" + self.key.debugDescription + ")"
        }
    }

    public struct Extend: BodiedSyntax {
        public let key: String
        public private(set) var exports: [String: Export]
        public private(set) var context: [ParameterDeclaration]?
        private var externalsSet: Set<String>
        private var importSet: Set<String>

        public init(_ params: [ParameterDeclaration], body: [Syntax]) throws {
            guard params.count == 1 || params.count == 2 else {
                throw LeafError(.unknownError("extend only supports one or two parameters \(params)"))
            }
            if params.count == 2 {
                guard let context = With.extract(params: Array(params[1...])) else {
                    throw LeafError(.unknownError("#extend's context requires a single expression"))
                }
                self.context = context
            }
            guard case .parameter(let p) = params[0] else {
                throw LeafError(.unknownError("extend expected parameter type, got \(params[0])"))
            }
            guard case .stringLiteral(let s) = p else {
                throw LeafError(.unknownError("import only supports string literals"))
            }
            self.key = s
            self.externalsSet = .init(arrayLiteral: self.key)
            self.importSet = .init()
            self.exports = [:]

            try body.forEach { syntax in
                switch syntax {
                // extend can ONLY export, raw space in body ignored
                case .raw:
                    break
                case .export(let export):
                    guard !export.externals().contains(self.key) else {
                        throw LeafError(.cyclicalReference(self.key, [self.key]))
                    }
                    self.exports[export.key] = export
                    self.externalsSet.formUnion(export.externals())
                    self.importSet.formUnion(export.imports())
                default:
                    throw LeafError(.unknownError("unexpected token in extend body: \(syntax).. use raw space and `export` only"))
                }
            }
        }
        
        init(key: String, exports: [String : Syntax.Export], externalsSet: Set<String>, importSet: Set<String>) {
            self.key = key
            self.exports = exports
            self.externalsSet = externalsSet
            self.importSet = importSet
        }
        
        func externals() -> Set<String> {
            self.externalsSet
        }
        func imports() -> Set<String> {
            self.importSet
        }
        
        func inlineRefs(_ externals: [String: LeafAST], _ imports: [String : Syntax.Export]) -> [Syntax] {
            var newExports = [String: Export]()
            var newImports = imports
            var newExternalsSet = Set<String>()
            var newImportSet = Set<String>()
            
            // In the case where #exports themselves contain #extends or #imports, rebuild those
            for (key, value) in self.exports {
                guard !value.externals().isEmpty || !value.imports().isEmpty else {
                    newExports[key] = value
                    continue
                }
                guard case .export(let e) = value.inlineRefs(externals, imports).first else {
                    fatalError()
                }
                newExports[key] = e
                newExternalsSet.formUnion(e.externals())
                newImportSet.formUnion(e.imports())
            }
            
            // Now add this extend's exports onto the passed imports
            newExports.forEach {
                newImports[$0.key] = $0.value
            }
            
            var results = [Syntax]()
            
            // Either return a rebuilt #extend or an inlined and (potentially partially) resolved extended syntax
            if !externals.keys.contains(self.key) {
                let resolvedExtend = Syntax.Extend(
                    key: self.key,
                    exports: newExports,
                    externalsSet: self.externalsSet,
                    importSet: newImportSet
                )
                results.append(.extend(resolvedExtend))
            } else {
                // Get the external AST
                let newAst = externals[self.key]!
                // Remove this AST from the externals to avoid needless checks
                let externals = externals.filter { $0.key != self.key }
                newAst.ast.forEach {
                    // Add each external syntax, resolving with the current available
                    // exports and passing this extend's exports to the syntax's imports
                    
                    results += $0.inlineRefs(externals, newImports)
                    // expressions may have been created by imports, convert
                    // single parameter static values to .raw
                    if case .expression(let e) = results.last, let raw = e.atomicRaw() {
                        results.removeLast()
                        results.append(raw)
                    }
                }
            }
            
            return results
        }
        
        func availableExports() -> Set<String> {
            .init(self.exports.keys)
        }

        func print(depth: Int) -> String {
            var print = indent(depth)
            if let context = self.context {
                print += "extend(" + self.key.debugDescription + "," + context.debugDescription + ")"
            } else {
                print += "extend(" + self.key.debugDescription + ")"
            }
            if !self.exports.isEmpty {
                print += ":\n" + self.exports.sorted { $0.key < $1.key } .map { $0.1.print(depth: depth + 1) } .joined(separator: "\n")
            }
            return print
        }
    }

    public struct Export: BodiedSyntax {
        public let key: String
        public internal(set) var body: [Syntax]
        private var externalsSet: Set<String>
        private var importSet: Set<String>

        public init(_ params: [ParameterDeclaration], body: [Syntax]) throws {
            guard (1...2).contains(params.count) else {
                throw LeafError(.unknownError("export expects 1 or 2 params"))
            }
            guard case .parameter(let p) = params[0] else {
                throw LeafError(.unknownError("expected parameter"))
            }
            guard case .stringLiteral(let s) = p else {
                throw LeafError(.unknownError("export only supports string literals"))
            }
            self.key = s

            if params.count == 2 {
            //    guard case .parameter(let _) = params[1] else { throw LeafError(.unknownError("expected parameter")) }
                guard body.isEmpty else {
                    throw LeafError(.unknownError("extend w/ two args requires NO body"))
                }
                self.body = [.expression([params[1]])]
                self.externalsSet = .init()
                self.importSet = .init()
            } else {
                guard !body.isEmpty else {
                    throw LeafError(.unknownError("export requires body or secondary arg"))
                }
                self.body = body
                self.externalsSet = body.externals()
                self.importSet = body.imports()
            }
        }
        
        init(key: String, body: [Syntax]) {
            self.key = key
            self.body = body
            self.externalsSet = body.externals()
            self.importSet = body.imports()
        }
        
        func externals() -> Set<String> {
            self.externalsSet
        }
        
        func imports() -> Set<String> {
            self.importSet
        }
        
        func inlineRefs(_ externals: [String: LeafAST], _ imports: [String : Syntax.Export]) -> [Syntax] {
            guard !self.externalsSet.isEmpty || !self.importSet.isEmpty else {
                return [.export(self)]
            }
            return [.export(.init(key: self.key, body: self.body.inlineRefs(externals, imports)))]
        }

        func print(depth: Int) -> String {
            var print = indent(depth)
            print += "export(" + self.key.debugDescription + ")"
            if !self.body.isEmpty {
                print += ":\n" + self.body.map { $0.print(depth: depth + 1) } .joined(separator: "\n")
            }
            return print
        }
    }

    public struct Conditional: BodiedSyntax {
        public internal(set) var chain: [(
            condition: ConditionalSyntax,
            body: [Syntax]
        )]
        
        private var externalsSet: Set<String>
        private var importSet: Set<String>

        public init(_ condition: ConditionalSyntax, body: [Syntax]) {
            self.chain = []
            self.chain.append((condition, body))
            self.externalsSet = body.externals()
            self.importSet = body.imports()
            self.importSet.formUnion(condition.imports())
        }
        
        init(chain: [(condition: ConditionalSyntax, body: [Syntax])], externalsSet: Set<String>, importSet: Set<String>) {
            self.chain = chain
            self.externalsSet = externalsSet
            self.importSet = importSet
        }

        mutating func attach(_ new: Conditional) throws {
            if self.chain.isEmpty {
                self.chain = new.chain
                self.importSet = new.importSet
            } else if !new.chain.isEmpty {
                let state = self.chain.last!.condition.naturalType
                let next = new.chain.first!.condition.naturalType
                if next.rawValue > state.rawValue || (state == next && state == .elseif) {
                    self.chain.append(contentsOf: new.chain)
                    self.externalsSet.formUnion(new.externalsSet)
                    self.importSet.formUnion(new.importSet)
                } else {
                    throw LeafError(.unknownError("\(next.description) can't follow \(state.description)"))
                }
            }
        }
        
        func externals() -> Set<String> {
            self.externalsSet
        }
        
        func imports() -> Set<String> {
            self.importSet
        }
        
        func inlineRefs(_ externals: [String: LeafAST], _ imports: [String : Syntax.Export]) -> [Syntax] {
            guard !self.externalsSet.isEmpty || !self.importSet.isEmpty else {
                return [.conditional(self)]
            }
            var newChain = [(ConditionalSyntax, [Syntax])]()
            var newImportSet = Set<String>()
            var newExternalsSet = Set<String>()
            
            self.chain.forEach {
                if !$0.body.externals().isEmpty || !$0.body.imports().isEmpty || !$0.condition.imports().isEmpty {
                    newChain.append(($0.0.inlineImports(imports), $0.1.inlineRefs(externals, imports)))
                    newImportSet.formUnion(newChain.last!.0.imports())
                    newImportSet.formUnion(newChain.last!.1.imports())
                    newExternalsSet.formUnion(newChain.last!.1.externals())
                } else {
                    newChain.append($0)
                }
            }
            
            return [.conditional(.init(chain: newChain, externalsSet: newExternalsSet, importSet: newImportSet))]
        }

        func print(depth: Int) -> String {
            var print = indent(depth) + "conditional:\n"
            print += self._print(depth: depth + 1)
            return print
        }

        private func _print(depth: Int) -> String {
            let buffer = indent(depth)

            var print = ""
            
            for index in self.chain.indices {
                switch self.chain[index].condition {
                    case .if(let params):
                        print += buffer + "if(" + params.map { $0.description } .joined(separator: ", ") + ")"
                    case .elseif(let params):
                        print += buffer + "elseif(" + params.map { $0.description } .joined(separator: ", ") + ")"
                    case .else:
                        print += buffer + "else"
                }

                if !self.chain[index].body.isEmpty {
                    print += ":\n" + self.chain[index].body.map { $0.print(depth: depth + 1) } .joined(separator: "\n")
                }
                
                if index != self.chain.index(before: self.chain.endIndex) { print += "\n" }
            }

            return print
        }
    }

    public struct With: BodiedSyntax {
        public internal(set) var body: [Syntax]
        public internal(set) var context: [ParameterDeclaration]

        private var externalsSet: Set<String>
        private var importSet: Set<String>

        func externals() -> Set<String> {
            self.externalsSet
        }

        func imports() -> Set<String> {
            self.importSet
        }

        func inlineRefs(_ externals: [String : LeafAST], _ imports: [String : Syntax.Export]) -> [Syntax] {
            guard !self.externalsSet.isEmpty || !self.importSet.isEmpty else { return [.with(self)] }
            return [.with(.init(context: self.context, body: self.body.inlineRefs(externals, imports)))]
        }

        init(context: [ParameterDeclaration], body: [Syntax]) {
            self.context = context
            self.body = body
            self.externalsSet = body.externals()
            self.importSet = body.imports()
        }

        static func extract(params: [ParameterDeclaration]) -> [ParameterDeclaration]? {
            if params.count == 1, case .expression(let list) = params[0] {
                return list
            }
            if params.count == 1, case .parameter = params[0] {
                return params
            }
            return nil
        }

        public init(_ params: [ParameterDeclaration], body: [Syntax]) throws {
            Swift.print(params)
            guard let params = With.extract(params: params) else {
                throw LeafError(.unknownError("with statements expect a single expression"))
            }
            guard !body.isEmpty else {
                throw LeafError(.unknownError("with statements require a body"))
            }
            self.body = body
            self.context = params
            self.externalsSet = body.externals()
            self.importSet = body.imports()
        }

        func print(depth: Int) -> String {
            var print = indent(depth)
            print += "with(\(self.context)):\n"
            print += self.body.map { $0.print(depth: depth + 1) } .joined(separator: "\n")
            return print
        }
    }

    public struct Loop: BodiedSyntax {
        /// the key to use when accessing items
        public let item: String
        /// the key to use to access the array
        public let array: String
        /// the key to use when accessing the current index
        public let index: String

        /// the body of the looop
        public internal(set) var body: [Syntax]
        
        private var externalsSet: Set<String>
        private var importSet: Set<String>

        /// initialize a new loop
        public init(_ params: [ParameterDeclaration], body: [Syntax]) throws {
            if params.count == 1 {
                guard
                    case .expression(let list) = params[0],
                    list.count == 3,
                    case .parameter(let left) = list[0],
                    case .variable(let item) = left,
                    case .parameter(let `in`) = list[1],
                    case .keyword(let k) = `in`,
                    k == .in,
                    case .parameter(let right) = list[2],
                    case .variable(let array) = right
                else {
                    throw LeafError(.unknownError("for loops expect one of the following expressions: 'name in names' or 'nameIndex, name in names'"))
                }
                self.item = item
                self.array = array
                self.index = "index"
            } else {
                guard
                    params.count == 2,
                    case .parameter(.variable(let index)) = params[0],
                    case .expression(let list) = params[1],
                    list.count == 3,
                    case .parameter(let left) = list[0],
                    case .variable(let item) = left,
                    case .parameter(let `in`) = list[1],
                    case .keyword(let k) = `in`,
                    k == .in,
                    case .parameter(let right) = list[2],
                    case .variable(let array) = right
                else {
                    throw LeafError(.unknownError("for loops expect one of the following expressions: 'name in names' or 'nameIndex, name in names'"))
                }
                self.item = item
                self.array = array
                self.index = index
            }

            guard !body.isEmpty else {
                throw LeafError(.unknownError("for loops require a body"))
            }
            self.body = body
            self.externalsSet = body.externals()
            self.importSet = body.imports()
        }
        
        init(item: String, array: String, index: String, body: [Syntax]) {
            self.item = item
            self.array = array
            self.index = index
            self.body = body
            self.externalsSet = body.externals()
            self.importSet = body.imports()
        }
        
        func externals() -> Set<String> {
            self.externalsSet
        }
        
        func imports() -> Set<String> {
            self.importSet
        }

        func inlineRefs(_ externals: [String: LeafAST], _ imports: [String : Syntax.Export]) -> [Syntax] {
            guard !self.externalsSet.isEmpty || !self.importSet.isEmpty else {
                return [.loop(self)]
            }
            return [.loop(.init(item: self.item, array: self.array, index: self.index, body: self.body.inlineRefs(externals, imports)))]
        }
        
        func print(depth: Int) -> String {
            var print = indent(depth)
            print += "for(" + (index == "index" ? "" : "\(self.index), ") + self.item + " in " + self.array + "):\n"
            print += self.body.map { $0.print(depth: depth + 1) } .joined(separator: "\n")
            return print
        }
    }

    public struct CustomTagDeclaration: BodiedSyntax {
        public let name: String
        public let params: [ParameterDeclaration]
        public internal(set) var body: [Syntax]?
        private var externalsSet: Set<String>
        private var importSet: Set<String>
        
        init(name: String, params: [ParameterDeclaration], body: [Syntax]? = nil) {
            self.name = name
            self.params = params
            self.externalsSet = .init()
            self.importSet = params.imports()
            self.body = body
            if let b = body {
                self.externalsSet.formUnion(b.externals())
                self.importSet.formUnion(b.imports())
            }
        }
        
        func externals() -> Set<String> {
            self.externalsSet
        }
        
        func imports() -> Set<String> {
            self.importSet
        }
        
        func inlineRefs(_ externals: [String: LeafAST], _ imports: [String : Syntax.Export]) -> [Syntax] {
            guard !self.importSet.isEmpty || !self.externalsSet.isEmpty else {
                return [.custom(self)]
            }
            let p = self.params.imports().isEmpty ? self.params : self.params.inlineImports(imports)
            let b = self.body.map { $0.inlineRefs(externals, imports) }
            return [.custom(.init(name: self.name, params: p, body: b))]
        }

        func print(depth: Int) -> String {
            var print = indent(depth)
            print += self.name + "(" + self.params.map { $0.description } .joined(separator: ", ") + ")"
            if let body = self.body, !body.isEmpty {
                print += ":\n" + body.map { $0.print(depth: depth + 1) } .joined(separator: "\n")
            }
            return print
        }
    }
}

extension Syntax: CustomStringConvertible {
    public var description: String {
        print(depth: 0)
    }

    func print(depth: Int) -> String {
        switch self {
        case .expression(let exp): return indent(depth) + "expression\(exp.description)"
//           case .variable(let v):     return v.print(depth: depth)
        case .custom(let custom):  return custom.print(depth: depth)
        case .conditional(let c):  return c.print(depth: depth)
        case .loop(let loop):      return loop.print(depth: depth)
        case .import(let imp):     return imp.print(depth: depth)
        case .extend(let ext):     return ext.print(depth: depth)
        case .export(let export):  return export.print(depth: depth)
        case .with(let with):      return with.print(depth: depth)
        case .raw(var bB):
            let string = bB.readString(length: bB.readableBytes) ?? ""
            return indent(depth) + "raw(\(string.debugDescription))"
        }
    }
}

### File: leaf-kit/Sources/LeafKit/LeafSyntax/LeafTag.swift ###
import Foundation

/// Create custom tags by conforming to this protocol and registering them.
public protocol LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData
}

/// Tags conforming to this protocol do not get their contents HTML-escaped.
public protocol UnsafeUnescapedLeafTag: LeafTag {}

// Why is this even mutable? We have no choice but to silence the compiler's legitimate warning about
// safety because we can't remove the setter.
public nonisolated(unsafe) var defaultTags: [String: any LeafTag] = [
    "unsafeHTML": UnsafeHTML(),
    "lowercased": Lowercased(),
    "uppercased": Uppercased(),
    "capitalized": Capitalized(),
    "contains": Contains(),
    "isEmpty": IsEmpty(),
    "date": DateTag(),
    "count": Count(),
    "comment": Comment(),
    "dumpContext": DumpContext()
]

struct UnsafeHTML: UnsafeUnescapedLeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        guard let str = ctx.parameters.first?.string else {
            throw LeafError(.unknownError("unable to unsafe unexpected data"))
        }
        return .init(.string(str))
    }
}

struct Lowercased: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        guard let str = ctx.parameters.first?.string else {
            throw LeafError(.unknownError("unable to lowercase unexpected data"))
        }
        return .init(.string(str.lowercased()))
    }
}

struct Uppercased: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        guard let str = ctx.parameters.first?.string else {
            throw LeafError(.unknownError("unable to uppercase unexpected data"))
        }
        return .init(.string(str.uppercased()))
    }
}

struct Capitalized: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        guard let str = ctx.parameters.first?.string else {
            throw LeafError(.unknownError("unable to capitalize unexpected data"))
        }
        return .init(.string(str.capitalized))
    }
}

struct Contains: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        try ctx.requireParameterCount(2)
        guard let collection = ctx.parameters[0].array else {
            throw LeafError(.unknownError("unable to convert first parameter to array"))
        }
        let result = collection.contains(ctx.parameters[1])
        return .init(.bool(result))
    }
}

struct IsEmpty: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        guard let str = ctx.parameters.first?.string else {
            throw LeafError(.unknownError("unable to check for empty value unexpected data"))
        }
        return .init(.bool(str.isEmpty))
    }
}

struct DateTag: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        let formatter = DateFormatter()
        switch ctx.parameters.count {
        case 1: formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss"
        case 2:
            guard let string = ctx.parameters[1].string else {
                throw LeafError(.unknownError("Unable to convert date format to string"))
            }
            formatter.dateFormat = string
        case 3:
            guard let string = ctx.parameters[1].string else {
                throw LeafError(.unknownError("Unable to convert date format to string"))
            }
            formatter.dateFormat = string
            guard let timeZone = ctx.parameters[2].string else {
                throw LeafError(.unknownError("Unable to convert time zone to string"))
            }
            formatter.timeZone = TimeZone(identifier: timeZone)
        default:
            throw LeafError(.unknownError("invalid parameters provided for date"))
        }

        guard let dateAsDouble = ctx.parameters.first?.double else {
            throw LeafError(.unknownError("Unable to convert parameter to double for date"))
        }
        let date = Date(timeIntervalSince1970: dateAsDouble)

        let dateAsString = formatter.string(from: date)
        return .string(dateAsString)
    }
}

struct Count: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        try ctx.requireParameterCount(1)
        if let array = ctx.parameters[0].array {
            return LeafData.int(array.count)
        } else if let dictionary = ctx.parameters[0].dictionary {
            return LeafData.int(dictionary.count)
        } else {
            throw LeafError(.unknownError("Unable to convert count parameter to LeafData collection"))
        }
    }
}

struct Comment: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        .trueNil
    }
}

struct DumpContext: LeafTag {
    func render(_ ctx: LeafContext) throws -> LeafData {
        try ctx.requireParameterCount(0)
        return .dictionary(ctx.data)
    }
}

### File: leaf-kit/Tests/LeafKitTests/HTMLEscapeTests.swift ###
@testable import LeafKit
import XCTest

final class HTMLEscapeTests: XCTestCase {
    func testCorrectness() {
        XCTAssertEqual("".htmlEscaped(), "")
        XCTAssertEqual("abcdef".htmlEscaped(), "abcdef")
        XCTAssertEqual("abc&<>\"'".htmlEscaped(), "abc&amp;&lt;&gt;&quot;&#39;")
        XCTAssertEqual("abc&".htmlEscaped(), "abc&amp;")
    }

    #if !os(Android)
    func testShortStringNoReplacements() {
        let string = "abcde12345"
        measure {
            _ = string.htmlEscaped()
        }
    }

    func testShortStringWithReplacements() {
        // The result should still fit into 15 bytes to hit the in-place String storage optimization.
        let string = "<abcdef>"
        measure {
            _ = string.htmlEscaped()
        }
    }

    static let mediumStringNoReplacements: String = {
        let lowercase = Array(UInt8(ascii: "a")...UInt8(ascii: "z"))
        let digits = Array(UInt8(ascii: "0")...UInt8(ascii: "9"))
        let uppercase = Array(UInt8(ascii: "A")...UInt8(ascii: "Z"))

        return String(bytes: lowercase + digits + uppercase, encoding: .utf8)!
    }()

    func testMediumStringNoReplacements() {
        measure {
            _ = HTMLEscapeTests.mediumStringNoReplacements.htmlEscaped()
        }
    }

    static let mediumStringWithReplacements: String = {
        let lowercase = Array(UInt8(ascii: "a")...UInt8(ascii: "z"))
        let digits = Array(UInt8(ascii: "0")...UInt8(ascii: "9"))
        let uppercase = Array(UInt8(ascii: "A")...UInt8(ascii: "Z"))
        let allCharacters = [[UInt8(ascii: "&")], lowercase, [UInt8(ascii: "\"")], digits, [UInt8(ascii: "'")], uppercase, [UInt8(ascii: "<")], [UInt8(ascii: ">")]]
            .flatMap { $0 }

        return String(bytes: allCharacters, encoding: .utf8)!
    }()

    func testMediumStringWithReplacements() {
        measure {
            _ = HTMLEscapeTests.mediumStringWithReplacements.htmlEscaped()
        }
    }

    func testMediumStringWithOnlyReplacements() {
        let string = Array(repeating: "&<>\"'", count: 10).joined(separator: "")
        measure {
            _ = string.htmlEscaped()
        }
    }

    func testLongStringNoReplacements() {
        let longString = Array(repeating: HTMLEscapeTests.mediumStringNoReplacements, count: 20).joined(separator: "")
        measure {
            _ = longString.htmlEscaped()
        }
    }

    func testLongStringWithReplacements() {
        let longString = Array(repeating: HTMLEscapeTests.mediumStringWithReplacements, count: 20).joined(separator: "")
        measure {
            _ = longString.htmlEscaped()
        }
    }
    #endif
}

### File: leaf-kit/Tests/LeafKitTests/LeafErrorTests.swift ###
/// Place all tests related to verifying that errors ARE thrown here.

@testable import LeafKit
import XCTest

final class LeafErrorTests: XCTestCase {
    /// Verify that cyclical references via #extend will throw `LeafError.cyclicalReference`
    func testCyclicalError() async throws {
        var test = TestFiles()
        test.files["/a.leaf"] = "#extend(\"b\")"
        test.files["/b.leaf"] = "#extend(\"c\")"
        test.files["/c.leaf"] = "#extend(\"a\")"

        await XCTAssertThrowsErrorAsync(try await TestRenderer(sources: .singleSource(test)).render(path: "a")) {
            switch ($0 as? LeafError)?.reason {
            case .cyclicalReference(let name, let cycle):
                XCTAssertEqual(name, "a")
                XCTAssertEqual(cycle, ["a", "b", "c", "a"])
            default:
                XCTFail("Expected .cyclicalReference(a, [a, b, c, a]), got \($0.localizedDescription)")
            }
        }
    }
    
    /// Verify that referencing a non-existent template will throw `LeafError.noTemplateExists`
    func testDependencyError() async throws {
        var test = TestFiles()
        test.files["/a.leaf"] = "#extend(\"b\")"
        test.files["/b.leaf"] = "#extend(\"c\")"

        await XCTAssertThrowsErrorAsync(try await TestRenderer(sources: .singleSource(test)).render(path: "a")) {
            switch ($0 as? LeafError)?.reason {
            case .noTemplateExists(let name):
                XCTAssertEqual(name, "c")
            default:
                XCTFail("Expected .noTemplateExists(c), got \($0.localizedDescription)")
            }
        }
    }
    
    /// Verify that rendering a template with a missing required parameter will throw `LeafError.missingParameter`
    func testMissingParameterError() async throws {
      var test = TestFiles()
      // Assuming "/missingParam.leaf" is a template that requires a parameter we intentionally don't provide
      test.files["/missingParam.leaf"] = """
          #(foo.bar.trim())
          """

        await XCTAssertThrowsErrorAsync(try await TestRenderer(sources: .singleSource(test)).render(path: "missingParam", context: [:])) {
            switch ($0 as? LeafError)?.reason {
            case .unknownError(let s):
                XCTAssertEqual(s, "Found nil while iterating through params")
            default:
                XCTFail("Expected .unknownError(Found nil while iterating through params), got \($0.localizedDescription)")
            }
        }
    }
}

### File: leaf-kit/Tests/LeafKitTests/LeafKitTests.swift ###
@testable import LeafKit
import NIOCore
import NIOPosix
import XCTest

final class ParserTests: XCTestCase {
    func testParsingNesting() throws {
        let input = """
        #if(lowercase(first(name == "admin")) == "welcome"):
        foo
        #endif
        """

        let expectation = """
        conditional:
          if([lowercase(first([name == "admin"])) == "welcome"]):
            raw("\\nfoo\\n")
        """

        let output = try parse(input).string
        XCTAssertEqual(output, expectation)
    }

    func testComplex() throws {
        let input = """
        #if(foo):
        foo
        #else:
        foo
        #endif
        """

        let expectation = """
        conditional:
          if(variable(foo)):
            raw("\\nfoo\\n")
          else:
            raw("\\nfoo\\n")
        """

        let output = try parse(input).string
        XCTAssertEqual(output, expectation)
    }

    func testCompiler() throws {
        let input = """
        #if(sayhello):
            abc
            #for(name in names):
                hi, #(name)
            #endfor
            def
        #else:
            foo
        #endif
        """

        let expectation = """
        conditional:
          if(variable(sayhello)):
            raw("\\n    abc\\n    ")
            for(name in names):
              raw("\\n        hi, ")
              expression[variable(name)]
              raw("\\n    ")
            raw("\\n    def\\n")
          else:
            raw("\\n    foo\\n")
        """

        let output = try parse(input).string
        XCTAssertEqual(output, expectation)
    }

    func testUnresolvedAST() throws {
        let base = """
        #extend("header")
        <title>#import("title")</title>
        #import("body")
        """

        let syntax = try parse(base)
        let ast = LeafAST(name: "base", ast: syntax)
        XCTAssertFalse(ast.unresolvedRefs.count == 0, "Unresolved template")
    }

    func testInsertResolution() throws {
        let header = """
        <h1>Hi!</h1>
        """
        let base = """
        #extend("header")
        <title>#import("title")</title>
        #import("body")
        """

        let baseAST = try LeafAST(name: "base", ast: parse(base))
        let headerAST = try LeafAST(name: "header", ast: parse(header))
        let baseResolvedAST = LeafAST(from: baseAST, referencing: ["header": headerAST])

        let output = baseResolvedAST.ast.string

        let expectation = """
        raw("<h1>Hi!</h1>\\n<title>")
        import("title")
        raw("</title>\\n")
        import("body")
        """
        XCTAssertEqual(output, expectation)
    }

    func testDocumentResolveExtend() throws {
        let header = """
        <h1>#import("header")</h1>
        """

        let base = """
        #extend("header")
        <title>#import("title")</title>
        #import("body")
        """

        let home = """
        #extend("base"):
            #export("title", "Welcome")
            #export("body"):
                Hello, #(name)!
            #endexport
        #endextend
        """

        let headerAST = try LeafAST(name: "header", ast: parse(header))
        let baseAST = try LeafAST(name: "base", ast: parse(base))
        let homeAST = try LeafAST(name: "home", ast: parse(home))

        let baseResolved = LeafAST(from: baseAST, referencing: ["header": headerAST])
        let homeResolved = LeafAST(from: homeAST, referencing: ["base": baseResolved])

        let output = homeResolved.ast.string
        let expectation = """
        raw("<h1>")
        import("header")
        raw("</h1>\\n<title>Welcome</title>\\n\\n        Hello, ")
        expression[variable(name)]
        raw("!\\n    ")
        """
        XCTAssertEqual(output, expectation)
    }

    func testCompileExtend() throws {
        let input = """
        #extend("base"):
            #export("title", "Welcome")
            #export("body"):
                Hello, #(name)!
            #endexport
        #endextend
        """

        let expectation = """
        extend("base"):
          export("body"):
            raw("\\n        Hello, ")
            expression[variable(name)]
            raw("!\\n    ")
          export("title"):
            expression[stringLiteral("Welcome")]
        """

        let output = try parse(input).string
        XCTAssertEqual(output, expectation)
    }
}

final class LexerTests: XCTestCase {
    func testParamNesting() throws {
        let input = """
        #if(lowercase(first(name == "admin")) == "welcome"):
        foo
        #endif
        """

        let expectation = """
        tagIndicator
        tag(name: "if")
        parametersStart
        param(tag("lowercase"))
        parametersStart
        param(tag("first"))
        parametersStart
        param(variable(name))
        param(operator(==))
        param(stringLiteral("admin"))
        parametersEnd
        parametersEnd
        param(operator(==))
        param(stringLiteral("welcome"))
        parametersEnd
        tagBodyIndicator
        raw("\\nfoo\\n")
        tagIndicator
        tag(name: "endif")

        """

        let output = try lex(input).string
        XCTAssertEqual(output, expectation)
    }

    func testConstant() throws {
        let input = "<h1>#(42)</h1>"
        let expectation = """
        raw("<h1>")
        tagIndicator
        tag(name: "")
        parametersStart
        param(constant(42))
        parametersEnd
        raw("</h1>")

        """

        let output = try lex(input).string
        XCTAssertEqual(output, expectation)
    }

    func testNoWhitespace() throws {
        let input1 = "#if(!one||!two)"
        let input2 = "#if(!one || !two)"
        let input3 = "#if(! one||! two)"
        let input4 = "#if(! one || ! two)"

        let output1 = try lex(input1).string
        let output2 = try lex(input2).string
        let output3 = try lex(input3).string
        let output4 = try lex(input4).string
        XCTAssertEqual(output1, output2)
        XCTAssertEqual(output2, output3)
        XCTAssertEqual(output3, output4)
    }

    // Base2/8/10/16 lexing for Int constants, Base10/16 for Double
    func testNonDecimals() throws {
        let input = "#(0b0101010 0o052 42 0_042 0x02A 0b0101010.0 0o052.0 42.0 0_042.0 0x02A.0)"
        let expectation = """
        tagIndicator
        tag(name: "")
        parametersStart
        param(constant(42))
        param(constant(42))
        param(constant(42))
        param(constant(42))
        param(constant(42))
        param(variable(0b0101010.0))
        param(variable(0o052.0))
        param(constant(42.0))
        param(constant(42.0))
        param(constant(42.0))
        parametersEnd

        """

        let output = try lex(input).string
        XCTAssertEqual(output, expectation)
    }

    func testEscaping() throws {
        // input is really '\#' w/ escaping
        let input = "\\#"
        let output = try lex(input).string
        XCTAssertEqual(output, "raw(\"#\")\n")
    }

    func testParameters() throws {
        let input = "#(foo == 40, and, \"literal\", and, foo_bar)"
        let expectation = """
        tagIndicator
        tag(name: "")
        parametersStart
        param(variable(foo))
        param(operator(==))
        param(constant(40))
        parameterDelimiter
        param(variable(and))
        parameterDelimiter
        param(stringLiteral("literal"))
        parameterDelimiter
        param(variable(and))
        parameterDelimiter
        param(variable(foo_bar))
        parametersEnd

        """
        let output = try lex(input).string
        XCTAssertEqual(output, expectation)
    }

    func testTags() throws {
        let input = """
        #tag
        #tag:
        #endtag
        #tag()
        #tag():
        #tag(foo)
        #tag(foo):
        """
        let expectation = """
        tagIndicator
        tag(name: "tag")
        raw("\\n")
        tagIndicator
        tag(name: "tag")
        tagBodyIndicator
        raw("\\n")
        tagIndicator
        tag(name: "endtag")
        raw("\\n")
        tagIndicator
        tag(name: "tag")
        parametersStart
        parametersEnd
        raw("\\n")
        tagIndicator
        tag(name: "tag")
        parametersStart
        parametersEnd
        tagBodyIndicator
        raw("\\n")
        tagIndicator
        tag(name: "tag")
        parametersStart
        param(variable(foo))
        parametersEnd
        raw("\\n")
        tagIndicator
        tag(name: "tag")
        parametersStart
        param(variable(foo))
        parametersEnd
        tagBodyIndicator

        """

        let output = try lex(input).string
        XCTAssertEqual(output, expectation)
    }

    func testNestedEcho() throws {
        let input = """
        #(todo)
        #(todo.title)
        #(todo.user.name.first)
        """
        let expectation = """
        tagIndicator
        tag(name: "")
        parametersStart
        param(variable(todo))
        parametersEnd
        raw("\\n")
        tagIndicator
        tag(name: "")
        parametersStart
        param(variable(todo.title))
        parametersEnd
        raw("\\n")
        tagIndicator
        tag(name: "")
        parametersStart
        param(variable(todo.user.name.first))
        parametersEnd

        """
        let output = try lex(input).string
        XCTAssertEqual(output, expectation)
    }
}

final class LeafKitTests: XCTestCase {
    func testNestedEcho() throws {
        let input = """
        Todo: #(todo.title)
        """
        var lexer = LeafLexer(name: "nested-echo", template: input)
        let tokens = try lexer.lex()
        var parser = LeafParser(name: "nested-echo", tokens: tokens)
        let ast = try parser.parse()
        var serializer = LeafSerializer(ast: ast, ignoreUnfoundImports: false)
        let view = try serializer.serialize(context: ["todo": ["title": "Leaf!"]])
        XCTAssertEqual(view.string, "Todo: Leaf!")
    }

    func testRendererContext() async throws {
        var test = TestFiles()
        test.files["/foo.leaf"] = "Hello #custom(name)"

        struct CustomTag: LeafTag {
            func render(_ ctx: LeafContext) throws -> LeafData {
                let prefix = ctx.userInfo["prefix"] as? String ?? ""
                let param = ctx.parameters.first?.string ?? ""
                return .string(prefix + param)
            }
        }

        let renderer = TestRenderer(
            tags: ["custom": CustomTag()],
            sources: .singleSource(test),
            userInfo: ["prefix": "bar"]
        )

        await XCTAssertEqualAsync(try await renderer.render(path: "foo", context: ["name": "vapor"]).string, "Hello barvapor")
    }

    func testImportResolve() async throws {
        var test = TestFiles()
        test.files["/a.leaf"] = """
            #extend("b"):
            #export("variable"):Hello#endexport
            #endextend
            """
            test.files["/b.leaf"] = """
            #import("variable")
            """

        let renderer = TestRenderer(sources: .singleSource(test))

        await XCTAssertEqualAsync(try await renderer.render(path: "a").string, "Hello")
    }

    #if !os(Android)
    func testCacheSpeedLinear() {
        self.measure {
            self._testCacheSpeedLinear(templates: 10, iterations: 100)
        }
    }

    func _testCacheSpeedLinear(templates: Int, iterations: Int) {
        let group = NIOSingletons.posixEventLoopGroup
        var test = TestFiles()

        for name in 1...templates { test.files["/\(name).leaf"] = "Template /\(name).leaf" }
        let renderer = TestRenderer(
            sources: .singleSource(test),
            eventLoop: group.any()
        )

        for iteration in 1...iterations {
            let template = String((iteration % templates) + 1)
            _ = try? renderer.render(path: template).wait(); renderer.finishTask()
        }

        XCTAssertEqual(renderer.r.cache.count, templates)
    }

    func testCacheSpeedRandom() {
        self.measure {
            // layer1 > layer2 > layer3
            self._testCacheSpeedRandom(layer1: 100, layer2: 20, layer3: 10, iterations: 130)
        }
    }

    func _testCacheSpeedRandom(layer1: Int, layer2: Int, layer3: Int, iterations: Int) {
        let group = NIOSingletons.posixEventLoopGroup
        var test = TestFiles()

        for name in 1...layer3 { test.files["/\(name)-3.leaf"] = "Template \(name)"}
        for name in 1...layer2 { test.files["/\(name)-2.leaf"] = "Template \(name) -> #extend(\"\((name % layer3)+1)-3\")"}
        for name in 1...layer1 { test.files["/\(name).leaf"] = "Template \(name) -> #extend(\"\(Int.random(in: 1...layer2))-2\") & #extend(\"\(Int.random(in: 1...layer2))-2\")" }

        let allKeys: [String] = test.files.keys.map{ String($0.dropFirst().dropLast(5)) }.shuffled()
        var hitList = allKeys
        let totalTemplates = allKeys.count
        let ratio = iterations / allKeys.count

        let renderer = TestRenderer(
            sources: .singleSource(test),
            eventLoop: group.any()
        )

        for x in (0..<iterations).reversed() {
            let template: String
            if x / ratio < hitList.count { template = hitList.removeFirst() }
            else { template = allKeys[Int.random(in: 0 ..< totalTemplates)] }
            _ = try? renderer.render(path: template).wait(); renderer.finishTask()
        }

        XCTAssertEqual(renderer.r.cache.count, layer1 + layer2 + layer3)
    }
    #endif

    func testImportParameter() async throws {
        var test = TestFiles()
        test.files["/base.leaf"] = """
            #extend("parameter"):
                #export("admin", admin)
            #endextend
            """
        test.files["/delegate.leaf"] = """
            #extend("parameter"):
                #export("delegated", false || bypass)
            #endextend
            """
        test.files["/parameter.leaf"] = """
            #if(import("admin")):
                Hi Admin
            #elseif(import("delegated")):
                Also an admin
            #else:
                No Access
            #endif
            """

        let renderer = TestRenderer(sources: .singleSource(test))
        
        await XCTAssertEqualAsync(try await renderer.render(path: "base", context: ["admin": false]).string, "\n    No Access\n")
        await XCTAssertEqualAsync(try await renderer.render(path: "base", context: ["admin": true]).string, "\n    Hi Admin\n")
        await XCTAssertEqualAsync(try await renderer.render(path: "delegate", context: ["bypass": true]).string, "\n    Also an admin\n")
    }
    
    func testDeepResolve() async throws {
        var test = TestFiles()
        test.files["/a.leaf"] = """
        #for(a in b):#if(false):Hi#elseif(true && false):Hi#else:#extend("b"):#export("derp"):DEEP RESOLUTION #(a)#endexport#endextend#endif#endfor
        """
        test.files["/b.leaf"] = """
        #import("derp")

        """

        let expected = """
        DEEP RESOLUTION 1
        DEEP RESOLUTION 2
        DEEP RESOLUTION 3

        """

        let renderer = TestRenderer(sources: .singleSource(test))

        await XCTAssertEqualAsync(try await renderer.render(path: "a", context: ["b":["1","2","3"]]).string, expected)
    }

    // The #filePath trick this test relies on doesn't work in the Android CI because the build
    // machine is not the same box as the test machine; we'd need to turn the templates into working
    // resources for that. Disable for now.
    #if !os(Android)
    func testFileSandbox() async throws {
        let renderer = TestRenderer(
            configuration: .init(rootDirectory: templateFolder),
            sources: .singleSource(NIOLeafFiles(
                fileio: .init(threadPool: NIOSingletons.posixBlockingThreadPool),
                limits: .default,
                sandboxDirectory: templateFolder,
                viewDirectory: templateFolder + "/SubTemplates"
            )),
            eventLoop: NIOSingletons.posixEventLoopGroup.any()
        )
        
        await XCTAssertNoThrowAsync(try await renderer.render(path: "test"))
        await XCTAssertNoThrowAsync(try await renderer.render(path: "../test"))
        await XCTAssertThrowsErrorAsync(try await renderer.render(path: "../../test")) {
            XCTAssert(($0 as? LeafError)?.localizedDescription.contains("Attempted to escape sandbox") ?? false)
        }
        await XCTAssertThrowsErrorAsync(try await renderer.render(path: ".test")) {
            XCTAssert(($0 as? LeafError)?.localizedDescription.contains("Attempted to access .test") ?? false)
        }
        XCTAssert(renderer.isDone)
    }
    #endif

    func testMultipleSources() async throws {
        var sourceOne = TestFiles()
        var sourceTwo = TestFiles()
        sourceOne.files["/a.leaf"] = "This file is in sourceOne"
        sourceTwo.files["/b.leaf"] = "This file is in sourceTwo"

        let multipleSources = LeafSources()
        try multipleSources.register(using: sourceOne)
        try multipleSources.register(source: "sourceTwo", using: sourceTwo)

        let unsearchableSources = LeafSources()
        try unsearchableSources.register(source: "unreachable", using: sourceOne, searchable: false)

        let goodRenderer = TestRenderer(sources: multipleSources)
        let emptyRenderer = TestRenderer(sources: unsearchableSources)
        
        XCTAssert(goodRenderer.r.sources.all.contains("sourceTwo"))
        XCTAssert(emptyRenderer.r.sources.searchOrder.isEmpty)

        await XCTAssertAsync(try await goodRenderer.render(path: "a").string.contains("sourceOne"))
        await XCTAssertAsync(try await goodRenderer.render(path: "b").string.contains("sourceTwo"))

        await XCTAssertThrowsErrorAsync(try await goodRenderer.render(path: "c")) {
            XCTAssert(($0 as? LeafError)?.localizedDescription.contains("No template found") ?? false)
        }
        await XCTAssertThrowsErrorAsync(try await emptyRenderer.render(path: "c")) {
            XCTAssert(($0 as? LeafError)?.localizedDescription.contains("No searchable sources exist") ?? false)
        }
    }

    func testBodyRequiring() async throws {
        var test = TestFiles()
        test.files["/body.leaf"] = "#bodytag:test#endbodytag"
        test.files["/bodyError.leaf"] = "#bodytag:#endbodytag"
        test.files["/nobody.leaf"] = "#nobodytag"
        test.files["/nobodyError.leaf"] = "#nobodytag:test#endnobodytag"

        struct BodyRequiringTag: UnsafeUnescapedLeafTag {
            func render(_ ctx: LeafContext) throws -> LeafData {
                _ = try ctx.requireBody()
                return .string("Hello there")
            }
        }

        struct NoBodyRequiringTag: UnsafeUnescapedLeafTag {
            func render(_ ctx: LeafContext) throws -> LeafData {
                try ctx.requireNoBody()
                return .string("General Kenobi")
            }
        }

        let renderer = TestRenderer(
            tags: [
                "bodytag": BodyRequiringTag(),
                "nobodytag": NoBodyRequiringTag()
            ],
            sources: .singleSource(test)
        )

        await XCTAssertEqualAsync(try await renderer.render(path: "body", context: ["test":"ciao"]).string, "Hello there")
        await XCTAssertThrowsErrorAsync(try await renderer.render(path: "bodyError", context: [:]))

        await XCTAssertEqualAsync(try await renderer.render(path: "nobody", context: [:]).string, "General Kenobi")
        await XCTAssertThrowsErrorAsync(try await renderer.render(path: "nobodyError", context: [:]))
    }
}

### File: leaf-kit/Tests/LeafKitTests/LeafSerializerTests.swift ###
@testable import LeafKit
import NIOCore
import XCTest

final class SerializerTests: XCTestCase {
    func testNestedKeyPathLoop() throws {
        let input = """
            #for(person in people):
            hello #(person.name)
            #for(skill in person.skills):
            you're pretty good at #(skill)
            #endfor
            #endfor
            """

        let syntax = try parse(input)
        let people = LeafData(.array([
            LeafData(.dictionary([
                "name": "LOGAN",
                "skills": LeafData(.array(["running", "walking"]))
            ]))
        ]))

        var serializer = LeafSerializer(ast: syntax, ignoreUnfoundImports: false)
        var serialized = try serializer.serialize(context: ["people": people])
        let str = (serialized.readString(length: serialized.readableBytes) ?? "<err>")

        XCTAssertEqual(str, """
        
        hello LOGAN

        you're pretty good at running

        you're pretty good at walking
        
        
        """)
    }

    func testInvalidNestedKeyPathLoop() throws {
        let input = """
            #for(person in people):
            hello #(person.name)
            #for(skill in person.profile.skills):
            you're pretty good at #(skill)
            #endfor
            #endfor
            """

        let syntax = try parse(input)
        let people = LeafData(.array([
            LeafData(.dictionary([
                "name": "LOGAN",
                "skills": LeafData(.array(["running", "walking"]))
            ]))
        ]))

        var serializer = LeafSerializer(ast: syntax, ignoreUnfoundImports: false)

        XCTAssertThrowsError(try serializer.serialize(context: ["people": people])) { error in
            XCTAssert((error as? LeafError)?.localizedDescription.contains("expected dictionary at key: person.profile") ?? false)
        }
    }
}

### File: leaf-kit/Tests/LeafKitTests/LeafTests.swift ###
@testable import LeafKit
import NIOCore
import XCTest

final class LeafTests: XCTestCase {
    // conversation ongoing
    func testCommentSugar() throws {
        let template = """
        #("foo")
        #comment:
            this is a comment!
        #endcomment
        bar
        """
        try XCTAssertEqual(render(template), "foo\n\nbar")
    }

    func testHashtag() throws {
        let template = """
        #("hi") #thisIsNotATag...
        """
        try XCTAssertEqual(render(template), "hi #thisIsNotATag...")
    }

    func testComplexIf() throws {
        let template = """
        #if(a): #if(b): hallo #else: #if(c): dallo #else: ballo #endif #endif #endif
        """

        let expectation = """
           ballo   
        """
        let rendered = try render(template, ["a": .string("true")])

        XCTAssertEqual(rendered, expectation)
    }

    func testNilIf() throws {
        let template = """
        #if(a != nil): not nil #else: nil #endif
        """

        let expectation = """
         not nil 
        """

        let rendered = try render(template, ["a": .string("hello")])

        XCTAssertEqual(rendered, expectation)
    }

    func testRaw() throws {
        let template = "Hello!"
        try XCTAssertEqual(render(template), "Hello!")
    }

    func testPrint() throws {
        let template = "Hello, #(name)!"
        try XCTAssertEqual(render(template, ["name": "Tanner"]), "Hello, Tanner!")
    }

    func testConstant() throws {
        let template = "<h1>#(42)</h1>"
        try XCTAssertEqual(render(template), "<h1>42</h1>")
    }

    func testNested() throws {
        let template = """
        <p>#(lowercased(foo))</p>
        """
        try XCTAssertEqual(render(template, ["foo": "BAR"]), "<p>bar</p>")
    }

    func testExpression() throws {
        let template = "#(age > 99)"
        try XCTAssertEqual(render(template, ["age": 21]), "false")
        try XCTAssertEqual(render(template, ["age": 150]), "true")
    }

    func testBody() throws {
        let template = """
        #if(show):hi#endif
        """
        try XCTAssertEqual(render(template, ["show": false]), "")
        try XCTAssertEqual(render(template, ["show": true]), "hi")
    }

    func testForSugar() throws {
        let template = """
        <p>
            <ul>
                #for(name in names):<li>#(name)</li>#endfor
            </ul>
        </p>
        """
        let expect = """
        <p>
            <ul>
                <li>Vapor</li><li>Leaf</li><li>Bits</li>
            </ul>
        </p>
        """
        try XCTAssertEqual(render(template, ["names": ["Vapor", "Leaf", "Bits"]]), expect)
    }

    func testIfSugar() throws {
        let template = """
        #if(false):Bad#elseif(true):Good#else:Bad#endif
        """
        try XCTAssertEqual(render(template), "Good")
    }

    func testNot() throws {
        let template = """
        #if(!false):Good#endif#if(!true):Bad#endif
        """
        try XCTAssertEqual(render(template), "Good")
    }

    func testNestedBodies() throws {
        let template = """
        #if(true):#if(true):Hello#endif#endif
        """
        try XCTAssertEqual(render(template), "Hello")
    }

    func testDotSyntax() throws {
        let template = """
        #if(user.isAdmin):Hello, #(user.name)!#endif
        """
        try XCTAssertEqual(render(template, ["user": ["isAdmin": true, "name": "Tanner"]]), "Hello, Tanner!")
    }

    func testEqual() throws {
        let template = """
        #if(id == 42):User 42!#endif#if(id != 42):Shouldn't show up#endif
        """
        try XCTAssertEqual(render(template, ["id": 42, "name": "Tanner"]), "User 42!")
    }

    func testStringIf() throws {
        let template = """
        #if(name):Hello, #(name)!#else:No Name!#endif
        """
        let expectedName = "Hello, Tanner!"
        let expectedNoName = "No Name!"
        try XCTAssertEqual(render(template, ["name": .string("Tanner")]), expectedName)
        try XCTAssertEqual(render(template), expectedNoName)
    }

    func testEqualIf() throws {
        let template = """
        #if(string1 == string2):Good#else:Bad#endif
        """
        let expectedGood = "Good"
        let expectedBad = "Bad"
        try XCTAssertEqual(render(template, ["string1": .string("Tanner"), "string2": .string("Tanner")]), expectedGood)
        try XCTAssertEqual(render(template, ["string1": .string("Tanner"), "string2": .string("n/a")]), expectedBad)
    }

    func testAndStringIf() throws {
        let template = """
        #if(name && one):Hello, #(name)#(one)!#elseif(name):Hello, #(name)!#else:No Name!#endif
        """
        let expectedNameOne = "Hello, Tanner1!"
        let expectedName = "Hello, Tanner!"
        let expectedNoName = "No Name!"
        try XCTAssertEqual(render(template, ["name": .string("Tanner"), "one": .string("1")]), expectedNameOne)
        try XCTAssertEqual(render(template, ["name": .string("Tanner")]), expectedName)
        try XCTAssertEqual(render(template), expectedNoName)
    }

    func testOrStringIf() throws {
        let template = """
        #if(name || one):Hello, #(name)#(one)!#else:No Name!#endif
        """
        let expectedName = "Hello, Tanner!"
        let expectedOne = "Hello, 1!"
        let expectedNoName = "No Name!"
        try XCTAssertEqual(render(template, ["name": .string("Tanner")]), expectedName)
        try XCTAssertEqual(render(template, ["one": .string("1")]), expectedOne)
        try XCTAssertEqual(render(template), expectedNoName)
    }

    func testArrayIf() throws {
        let template = """
        #if(namelist):#for(name in namelist):Hello, #(name)!#endfor#else:No Name!#endif
        """
        let expectedName = "Hello, Tanner!"
        let expectedNoName = "No Name!"
        try XCTAssertEqual(render(template, ["namelist": [.string("Tanner")]]), expectedName)
        try XCTAssertEqual(render(template), expectedNoName)
    }

    func testEscapeTag() throws {
        let template = """
        #("foo") \\#("bar")
        """
        let expected = """
        foo #("bar")
        """
        try XCTAssertEqual(render(template, [:]), expected)
    }

    func testEscapingQuote() throws {
        let template = """
        #("foo \\"bar\\"")
        """
        let expected = """
        foo "bar"
        """
        try XCTAssertEqual(render(template), expected)
    }

    func testCount() throws {
        let template = """
        count: #count(array)
        """
        let expected = """
        count: 4
        """
        try XCTAssertEqual(render(template, ["array": ["","","",""]]), expected)
    }

    func testDateFormat() throws {
        let template = """
        Date: #date(foo, "yyyy-MM-dd")
        """

        let expected = """
        Date: 1970-01-16
        """
        try XCTAssertEqual(render(template, ["foo": 1_337_000]), expected)

    }

    func testWith() throws {
        let template = """
        #with(parent):#(child)#endwith
        """
        let expected = """
        Elizabeth
        """

        try XCTAssertEqual(render(template, ["parent": ["child": "Elizabeth"]]), expected)
    }

    func testWithWrappingExtend() throws {
        let header = """
        <h1>#(child)</h1>
        """

        let base = """
        <body>#with(parent):<main>#extend("header")</main>#endwith</body>
        """

        let expected = """
        <body><main><h1>Elizabeth</h1></main></body>
        """

        let headerAST = try LeafAST(name: "header", ast: parse(header))
        let baseAST = try LeafAST(name: "base", ast: parse(base))

        let baseResolved = LeafAST(from: baseAST, referencing: ["header": headerAST])

        var serializer = LeafSerializer(
            ast: baseResolved.ast,
            ignoreUnfoundImports: false
        )
        let view = try serializer.serialize(context: ["parent": ["child": "Elizabeth"]])
        let str = view.getString(at: view.readerIndex, length: view.readableBytes) ?? ""

        XCTAssertEqual(str, expected)
    }

    func testExtendWithSugar() throws {
        let header = """
        <h1>#(child)</h1>
        """

        let base = """
        #extend("header", parent)
        """

        let expected = """
        <h1>Elizabeth</h1>
        """

        let headerAST = try LeafAST(name: "header", ast: parse(header))
        let baseAST = try LeafAST(name: "base", ast: parse(base))

        let baseResolved = LeafAST(from: baseAST, referencing: ["header": headerAST])

        var serializer = LeafSerializer(
            ast: baseResolved.ast,
            ignoreUnfoundImports: false
        )
        let view = try serializer.serialize(context: ["parent": ["child": "Elizabeth"]])
        let str = view.getString(at: view.readerIndex, length: view.readableBytes) ?? ""

        XCTAssertEqual(str, expected)
    }

    func testNestedExtendWithSugar() throws {
        let layout = """
        <body>#import("content")</body>
        """

        let header = """
        <h1>#(child)</h1>
        """

        let base = """
        #extend("layout"):#export("content"):<main>#extend("header", parent)</main>#endexport#endextend
        """

        let expected = """
        <body><main><h1>Elizabeth</h1></main></body>
        """

        let layoutAST = try LeafAST(name: "layout", ast: parse(layout))
        let headerAST = try LeafAST(name: "header", ast: parse(header))
        let baseAST = try LeafAST(name: "base", ast: parse(base))

        let baseResolved = LeafAST(from: baseAST, referencing: ["layout": layoutAST, "header": headerAST])

        var serializer = LeafSerializer(
            ast: baseResolved.ast,
            ignoreUnfoundImports: false
        )
        let view = try serializer.serialize(context: ["parent": ["child": "Elizabeth"]])
        let str = view.getString(at: view.readerIndex, length: view.readableBytes) ?? ""

        XCTAssertEqual(str, expected)
    }

    func testEmptyForLoop() throws {
        let template = """
        #for(category in categories):
            <a class=dropdown-item href=#>#(category.name)</a>
        #endfor
        """
        let expected = """
        """

        struct Category: Encodable {
            var name: String
        }

        struct Context: Encodable {
            var categories: [Category]
        }
        
        try XCTAssertEqual(render(template, ["categories": []]), expected)

    }

    func testKeyEqual() throws {
        let template = """
        #if(title == "foo"):it's foo#else:not foo#endif
        """
        let expected = """
        it's foo
        """

        struct Stuff: Encodable {
            var title: String
        }

        try XCTAssertEqual(render(template, ["title": "foo"]), expected)
    }

    func testLoopIndices() throws {
        let template = """
        #for(name in names):
            #(name) - index=#(index) last=#(isLast) first=#(isFirst)
        #endfor
        """
        let expected = """

            tanner - index=0 last=false first=true

            ziz - index=1 last=false first=false

            vapor - index=2 last=true first=false

        """

        try XCTAssertEqual(render(template, ["names": ["tanner", "ziz", "vapor"]]), expected)
    }

    func testNestedLoopIndices() throws {
        let template = """
        #for(array in arrays):
        Array#(index) - [#for(element in array): #(index)#if(isFirst):(first)#elseif(isLast):(last)#endif : "#(element)"#if(!isLast):, #endif#endfor]#endfor
        """
        let expected = """

        Array0 - [ 0(first) : "zero",  1 : "one",  2(last) : "two"]
        Array1 - [ 0(first) : "a",  1 : "b",  2(last) : "c"]
        Array2 - [ 0(first) : "red fish",  1 : "blue fish",  2(last) : "green fish"]
        """

        let data = LeafData.array([
            LeafData.array(["zero", "one", "two"]),
            LeafData.array(["a", "b", "c"]),
            LeafData.array(["red fish", "blue fish", "green fish"])
        ])

        try XCTAssertEqual(render(template, ["arrays": data]), expected)
    }

    func testNestedLoopCustomIndices() throws {
        let template = """
        #for(i, array in arrays):#for(j, element in array):
        (#(i), #(j)): #(element)#endfor#endfor
        """

        let expected = """

        (0, 0): zero
        (0, 1): one
        (0, 2): two
        (1, 0): a
        (1, 1): b
        (1, 2): c
        (2, 0): red fish
        (2, 1): blue fish
        (2, 2): green fish
        """

        let data = LeafData.array([
            LeafData.array(["zero", "one", "two"]),
            LeafData.array(["a", "b", "c"]),
            LeafData.array(["red fish", "blue fish", "green fish"])
        ])

        try XCTAssertEqual(render(template, ["arrays": data]), expected)
    }

    // It would be nice if a pre-render phase could catch things like calling
    // tags that would normally ALWAYS throw in serializing (eg, calling index
    // when not in a loop) so that warnings can be provided and AST can be minimized.
    func testLoopTagsInvalid() throws {
        let template = """
            #if(isFirst):Wrong#else:Right#endif
            """
            let expected = "Right"

        try XCTAssertEqual(render(template, [:]), expected)
    }

    // Current implementation favors context keys over tag keys, so
    // defining a key for isFirst in context will override accessing registered
    // LeafTags with the same name.
    // More reason to introduce scoping tag keys!!
    func testTagContextOverride() throws {
        let template = """
            #if(isFirst):Wrong (Maybe)#else:Right#endif
            """
            let expected = "Wrong (Maybe)"

        try XCTAssertEqual(render(template, ["isFirst": true]), expected)
    }
  
    // Validate parse resolution of negative numbers
    func testNegatives() throws {
        let input = """
        #(10)
        #(-10)
        """

        let syntax = """
        raw("10")
        raw("-10")
        """

        let expectation = """
        10
        -10
        """

        let parsed = try parse(input)
            .compactMap { $0.description != "raw(\"\\n\")" ? $0.description : nil }
            .joined(separator: "\n")
        XCTAssertEqual(parsed, syntax)
        try XCTAssertEqual(render(input), expectation)
    }

    // Validate parse resolution of evaluable expressions
    func testComplexParameters() throws {
        let input = """
        #(index-5)
        #(10-5)
        #(10 - 5)
        #(-5)
        """

        let syntax = """
        expression[variable(index), operator(-), constant(5)]
        expression[constant(10), operator(-), constant(5)]
        expression[constant(10), operator(-), constant(5)]
        raw("-5")
        """

        let expectation = """
        5
        5
        5
        -5
        """

        let parsed = try parse(input)
            .compactMap { $0.description != "raw(\"\\n\")" ? $0.description : nil }
            .joined(separator: "\n")
        XCTAssertEqual(parsed, syntax)
        try XCTAssertEqual(render(input,["index":10]), expectation)
    }

    // Validate parse resolution of negative numbers
    func testOperandGrouping() throws {
        let input = """
        #(!true&&!false)
        #((!true) || (!false))
        #((true) && (!false))
        #((!true) || (false))
        #(!true || !false)
        #(true)
        #(-5 + 10 - 20 / 2 + 9 * -3 == 90 / 3 + 0b010 * -0xA)
        """

        let syntax = """
        expression[keyword(false), operator(&&), keyword(true)]
        expression[keyword(false), operator(||), keyword(true)]
        expression[keyword(true), operator(&&), keyword(true)]
        expression[keyword(false), operator(||), keyword(false)]
        expression[keyword(false), operator(||), keyword(true)]
        raw("true")
        expression[[-5 + [10 - [[20 / 2] + [9 * -3]]]], operator(==), [[90 / 3] + [2 * -10]]]
        """

        let expectation = """
        false
        true
        true
        false
        true
        true
        false
        """

        let parsed = try parse(input)
            .compactMap { $0.description != "raw(\"\\n\")" ? $0.description : nil }
            .joined(separator: "\n")
        XCTAssertEqual(parsed, syntax)
        try XCTAssertEqual(render(input), expectation)
    }
}

### File: leaf-kit/Tests/LeafKitTests/TagTests.swift ###
@testable import LeafKit
import XCTest

final class TagTests: XCTestCase {
    func testWithHTMLEntities() throws {
        let template = """
        #(name)
        """
        let expected = """
        &lt;h1&gt;Alex&lt;/h1&gt;&quot;&#39;
        """
        try XCTAssertEqual(render(template, ["name": "<h1>Alex</h1>\"\'"]), expected)
    }

    func testUnsafeTag() throws {
        let template = """
        #unsafeHTML(name)
        """
        let expected = """
        <h1>Alex</h1>
        """
        try XCTAssertEqual(render(template, ["name": "<h1>Alex</h1>"]), expected)
    }

    func testUnsafeTagInteger() throws {
        let template = """
        #unsafeHTML(value)
        """
        let expected = """
        12345
        """
        try XCTAssertEqual(render(template, ["value": 12345]), expected)
    }

    func testLowercaseTag() throws {
        let template = """
        #lowercased(name)
        """
        let expected = """
        &lt;tim&gt;
        """
        try XCTAssertEqual(render(template, ["name": "<Tim>"]), expected)
    }

    func testLowercaseTagWithAllCaps() throws {
        let template = """
        #lowercased(name)
        """
        let expected = """
        tim
        """
        try XCTAssertEqual(render(template, ["name": "TIM"]), expected)
    }

    func testUppercaseTag() throws {
        let template = """
        #uppercased(name)
        """
        let expected = """
        TIM
        """
        try XCTAssertEqual(render(template, ["name": "Tim"]), expected)
    }

    func testUppercaseTagWithHTML() throws {
        let template = """
        #uppercased(name)
        """
        let expected = """
        &lt;H1&gt;TIM&lt;/H1&gt;
        """
        try XCTAssertEqual(render(template, ["name": "<h1>Tim</h1>"]), expected)
    }

    func testCapitalizedTag() throws {
        let template = """
        #capitalized(name)
        """
        let expected = """
        Tim
        """
        try XCTAssertEqual(render(template, ["name": "tim"]), expected)
    }

    func testCapitalizedTagWithHTML() throws {
        let template = """
        #capitalized(name)
        """
        let expected = """
        &lt;H1&gt;Tim&lt;/H1&gt;
        """
        try XCTAssertEqual(render(template, ["name": "<h1>tim</h1>"]), expected)
    }

    func testCount() throws {
        let template = """
        There are #count(people) people
        """

        let expected = """
        There are 5 people
        """
        try XCTAssertEqual(render(template, ["people": ["Tanner", "Logan", "Gwynne", "Siemen", "Tim"]]), expected)
    }

    func testContainsTag() throws {
        let template = """
        #if(contains(core, "Tanner")):
            Tanner is in the core team!
        #endif
        """

        let expected = """

            Tanner is in the core team!

        """
        try XCTAssertEqual(render(template, ["core": ["Tanner", "Logan", "Gwynne", "Siemen", "Tim"]]), expected)
    }
    
    func testIsEmpty() throws {
        let template = """
        #if(isEmpty(emptyString)):
            This is an empty string.
        #endif
        """

        let expected = """

            This is an empty string.

        """
        try XCTAssertEqual(render(template, ["emptyString": ""]), expected)
    }
    
    func testIsEmptyFalseCase() throws {
        let template = """
        #if(isEmpty(nonEmptyString)):
            This is an empty string.
        #else:
            This is not an empty string.
        #endif
        """

        let expected = """

            This is not an empty string.

        """
        try XCTAssertEqual(render(template, ["nonEmptyString": "I'm not empty."]), expected)
    }

    func testContainsTagWithHTML() throws {
        let template = """
        #if(contains(core, "<h1>Tanner</h1>")):
            Tanner is in the core team!
        #endif
        """

        let expected = """

            Tanner is in the core team!

        """
        try XCTAssertEqual(render(template, ["core": ["<h1>Tanner</h1>", "Logan", "Gwynne", "Siemen", "Tim"]]), expected)
    }


    func testDate() throws {
        let template = """
        The date is #date(now)
        """

        let expected = """
        The date is 2020-11-09T14:30:00
        """

        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss"
        formatter.timeZone = .current
        let date = formatter.date(from: "2020-11-09T14:30:00")!
        let now = Int(date.timeIntervalSince1970)

        try XCTAssertEqual(render(template, ["now": .int(now)]), expected)
    }

    func testDateWithCustomFormat() throws {
        let template = """
        The date is #date(now, "yyyy-MM-dd")
        """

        let expected = """
        The date is 2020-11-09
        """

        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss"
        formatter.timeZone = .init(secondsFromGMT: 0)
        let date = formatter.date(from: "2020-11-09T14:30:00")!
        let now = Int(date.timeIntervalSince1970)

        try XCTAssertEqual(render(template, ["now": .int(now)]), expected)
    }

    func testDateWithCustomFormatWithHTML() throws {
        let template = """
        The date is #date(now, "<yyyy-MM-dd>")
        """

        let expected = """
        The date is &lt;2020-11-09&gt;
        """

        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss"
        formatter.timeZone = .init(secondsFromGMT: 0)
        let date = formatter.date(from: "2020-11-09T14:30:00")!
        let now = Int(date.timeIntervalSince1970)

        try XCTAssertEqual(render(template, ["now": .int(now)]), expected)
    }

    func testDateWithCustomFormatAndTimeZone() throws {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss"
        formatter.timeZone = .init(secondsFromGMT: 0)
        let date = formatter.date(from: "2020-11-09T14:30:00")!
        let now = Int(date.timeIntervalSince1970)

        let templateNewYork = """
        The date is #date(now, "yyyy-MM-dd'T'HH:mm", "America/New_York")
        """

        let expectedNewYork = """
        The date is 2020-11-09T09:30
        """
        
        try XCTAssertEqual(render(templateNewYork, ["now": .int(now)]), expectedNewYork)
        
        let templateCalifornia = """
        The date is #date(now, "yyyy-MM-dd'T'HH:mm", "America/Los_Angeles")
        """

        let expectedCalifornia = """
        The date is 2020-11-09T06:30
        """
        
        try XCTAssertEqual(render(templateCalifornia, ["now": .int(now)]), expectedCalifornia)
    }

    func testDumpContext() throws {
        let data: [String: LeafData] = ["value": 12345]
        let template = """
        dumpContext should output debug description #dumpContext
        """

        let expected = """
        dumpContext should output debug description [value: "12345"]
        """

        try XCTAssertEqual(render(template, data), expected)
    }

    #if !os(Android)
    func testPerformance() throws {
        let template = """
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <title>#(title)</title>
          </head>
          <body>
            <h1>#(title)</h1>
            <p>#(paragraph1)</p>
            <p>#lowercased(paragraph2)</p>
            <p>#uppercased(paragraph3)</p>
            <p>#(someValue)</p>

            <ul>
                #for(item in list):
                    <li>#(item)</li>
                #endfor
            </ul>
          </body>
        </html>
        """

        func numberDescriptions(count: Int) -> String {
            (0..<count).map(\.description).joined(separator: " ")
        }

        let context: [String: LeafData] = [
            "title": .string(numberDescriptions(count: 2000)),
            "paragraph1": .string(numberDescriptions(count: 1000)),
            "paragraph2": .string(numberDescriptions(count: 1) + "<h1>asdf</h1>"),
            "paragraph3": .string(numberDescriptions(count: 300)),
            "someValue": .double(123123.321),
            "list": .array(
                (0..<1000).map { _ in .string(numberDescriptions(count: 1000)) }
            )
        ]

        measure {
            do {
                _ = try render(template, context)
            } catch {
                fatalError("render failed: \(error)")
            }
        }
    }
    #endif
}

### File: leaf-kit/Tests/LeafKitTests/TestHelpers.swift ###
@testable import LeafKit
import NIOCore
import NIOConcurrencyHelpers
import NIOEmbedded
import XCTest

/// Assorted multi-purpose helper pieces for LeafKit tests

// MARK: - Helper Functions

func XCTAssertThrowsErrorAsync<T>(
    _ expression: @autoclosure () async throws -> T,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath, line: UInt = #line,
    _ callback: (any Error) -> Void = { _ in }
) async {
    do {
        _ = try await expression()
        XCTAssertThrowsError({}(), message(), file: file, line: line, callback)
    } catch {
        XCTAssertThrowsError(try { throw error }(), message(), file: file, line: line, callback)
    }
}

func XCTAssertNoThrowAsync<T>(
    _ expression: @autoclosure () async throws -> T,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath, line: UInt = #line
) async {
    do {
        _ = try await expression()
    } catch {
        XCTAssertNoThrow(try { throw error }(), message(), file: file, line: line)
    }
}

func XCTAssertEqualAsync<T>(
    _ expression1: @autoclosure () async throws -> T,
    _ expression2: @autoclosure () async throws -> T,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath, line: UInt = #line
) async where T: Equatable {
    do {
        let expr1 = try await expression1(), expr2 = try await expression2()
        return XCTAssertEqual(expr1, expr2, message(), file: file, line: line)
    } catch {
        return XCTAssertEqual(try { () -> Bool in throw error }(), false, message(), file: file, line: line)
    }
}

func XCTAssertAsync(
    _ predicate: @autoclosure () async throws -> Bool,
    _ message: @autoclosure () -> String = "",
    file: StaticString = #filePath, line: UInt = #line
) async {
    do {
        let result = try await predicate()
        XCTAssert(result, message(), file: file, line: line)
    } catch {
        return XCTAssert(try { throw error }(), message(), file: file, line: line)
    }
}

/// Directly run a String "template" through `LeafLexer`
/// - Parameter str: Raw String holding Leaf template source data
/// - Returns: A lexed array of LeafTokens
func lex(_ str: String) throws -> [LeafToken] {
    var lexer = LeafLexer(name: "lex-test", template: str)
    return try lexer.lex().dropWhitespace()
}

/// Directly run a String "template" through `LeafLexer` and `LeafParser`
/// - Parameter str: Raw String holding Leaf template source data
/// - Returns: A lexed and parsed array of Syntax
func parse(_ str: String) throws -> [Syntax] {
    var lexer = LeafLexer(name: "alt-parse", template: str)
    let tokens = try lexer.lex()
    var parser = LeafParser(name: "alt-parse", tokens: tokens)
    let syntax = try parser.parse()

    return syntax
}

/// Directly run a String "template" through full render chain
/// - Parameter template: Raw String holding Leaf template source data
/// - Parameter context: LeafData context
/// - Returns: A fully rendered view
func render(name: String = "test-render", _ template: String, _ context: [String: LeafData] = [:]) throws -> String {
    var lexer = LeafLexer(name: name, template: template)
    let tokens = try lexer.lex()
    var parser = LeafParser(name: name, tokens: tokens)
    let ast = try parser.parse()
    var serializer = LeafSerializer(
        ast: ast,
        ignoreUnfoundImports: false
    )
    let view = try serializer.serialize(context: context)
    return view.getString(at: view.readerIndex, length: view.readableBytes) ?? ""
}

// MARK: - Helper Structs and Classes

/// Helper wrapping` LeafRenderer` to preconfigure for simplicity & allow eliding context
final class TestRenderer: Sendable {
    nonisolated(unsafe) let r: LeafRenderer
    private let lock: NIOLock
    private nonisolated(unsafe) var counter: Int = 0

    init(
        configuration: LeafConfiguration = .init(rootDirectory: "/"),
        tags: [String : any LeafTag] = defaultTags,
        cache: any LeafCache = DefaultLeafCache(),
        sources: LeafSources = .singleSource(TestFiles()),
        eventLoop: any EventLoop = EmbeddedEventLoop(),
        userInfo: [AnyHashable: Any] = [:]
    ) {
        self.r = .init(
            configuration: configuration,
            tags: tags,
            cache: cache,
            sources: sources,
            eventLoop: eventLoop,
            userInfo: userInfo
        )
        self.lock = .init()
    }
    
    func render(path: String, context: [String: LeafData] = [:]) -> EventLoopFuture<ByteBuffer> {
        self.lock.withLock { self.counter += 1 }
        return self.r.render(path: path, context: context)
    }

    @discardableResult
    func render(path: String, context: [String: LeafData] = [:]) async throws -> ByteBuffer {
        self.lock.withLock { self.counter += 1 }
        defer { self.lock.withLock { self.counter -= 1 } }
        return try await self.r.render(path: path, context: context).get()
    }

    public var isDone: Bool {
        self.lock.withLock { self.counter == 0 } ? true : false
    }
    
    func finishTask() {
        self.lock.withLock { self.counter -= 1 }
    }
}

/// Helper `LeafFiles` struct providing an in-memory thread-safe map of "file names" to "file data"
struct TestFiles: LeafSource {
    var files: [String: String] = [:]
    var lock: NIOLock = .init()

    func file(template: String, escape: Bool = false, on eventLoop: any EventLoop) -> EventLoopFuture<ByteBuffer> {
        var path = template
        if path.split(separator: "/").last?.split(separator: ".").count ?? 1 < 2, !path.hasSuffix(".leaf") {
            path += ".leaf"
        }
        if !path.starts(with: "/") {
            path = "/" + path
        }

        return self.lock.withLock {
            if let file = self.files[path] {
                return eventLoop.makeSucceededFuture(.init(string: file))
            } else {
                return eventLoop.makeFailedFuture(LeafError(.noTemplateExists(template)))
            }
        }
    }
}

// MARK: - Helper Extensions

extension ByteBuffer {
    var string: String {
        String(decoding: self.readableBytesView, as: UTF8.self)
    }
}

extension Array where Element == LeafToken {
    func dropWhitespace() -> Array<LeafToken> {
        self.filter { token in
            guard case .whitespace = token else { return true }
            return false
        }
    }
    
    var string: String {
        self.map { $0.description + "\n" }.reduce("", +)
    }
}

extension Array where Element == Syntax {
    var string: String {
        self.map { $0.description }.joined(separator: "\n")
    }
}

// MARK: - Helper Variables

/// Automatic path discovery for the Templates folder in this package
var templateFolder: String {
    URL(fileURLWithPath: projectTestFolder, isDirectory: true)
        .appendingPathComponent("Templates", isDirectory: true)
        .path
}

var projectTestFolder: String {
    URL(fileURLWithPath: #filePath, isDirectory: false) // .../leaf-kit/Tests/LeafKitTests/TestHelpers.swift
        .deletingLastPathComponent() // .../leaf-kit/Tests/LeafKitTests
        .path
}

// MARK: - Internal Tests

/// Test printing descriptions of Syntax objects
final class PrintTests: XCTestCase {    
    func testRaw() throws {
        let template = "hello, raw text"
        let expectation = "raw(\"hello, raw text\")"
        
        let v = try XCTUnwrap(parse(template).first)
        guard case .raw = v else { throw LeafError(.unknownError("nope")) }
        let output = v.print(depth: 0)
        XCTAssertEqual(output, expectation)
    }

    func testVariable() throws {
        let template = "#(foo)"
        let expectation = "variable(foo)"
        
        let v = try XCTUnwrap(parse(template).first)
        guard case .expression(let e) = v,
              let test = e.first else { throw LeafError(.unknownError("nope")) }
        let output = test.description
        XCTAssertEqual(output, expectation)
    }

    func testLoop() throws {
        let template = """
            #for(name in names):
                hello, #(name).
            #endfor
            """
        let expectation = """
            for(name in names):
              raw("\\n    hello, ")
              expression[variable(name)]
              raw(".\\n")
            """
        
        let v = try XCTUnwrap(parse(template).first)
        guard case .loop(let test) = v else { throw LeafError(.unknownError("nope")) }
        let output = test.print(depth: 0)
        XCTAssertEqual(output, expectation)
    }

    func testLoopCustomIndex() throws {
        let template = """
            #for(i, name in names):
                #(i): hello, #(name).
            #endfor
            """
        let expectation = """
            for(i, name in names):
              raw("\\n    ")
              expression[variable(i)]
              raw(": hello, ")
              expression[variable(name)]
              raw(".\\n")
            """

        let v = try XCTUnwrap(parse(template).first)
        guard case .loop(let test) = v else { throw LeafError(.unknownError("nope")) }
        let output = test.print(depth: 0)
        XCTAssertEqual(output, expectation)
    }

    func testConditional() throws {
        let template = """
            #if(foo):
                some stuff
            #elseif(bar == "bar"):
                bar stuff
            #else:
                no stuff
            #endif
            """
        let expectation = """
            conditional:
              if(variable(foo)):
                raw("\\n    some stuff\\n")
              elseif([bar == "bar"]):
                raw("\\n    bar stuff\\n")
              else:
                raw("\\n    no stuff\\n")
            """
        
        let v = try XCTUnwrap(parse(template).first)
        guard case .conditional(let test) = v else { throw LeafError(.unknownError("nope")) }
        let output = test.print(depth: 0)
        XCTAssertEqual(output, expectation)
    }

    func testImport() throws {
        let template = "#import(\"someimport\")"
        let expectation = "import(\"someimport\")"
        
        let v = try XCTUnwrap(parse(template).first)
        guard case .import(let test) = v else { throw LeafError(.unknownError("nope")) }
        let output = test.print(depth: 0)
        XCTAssertEqual(output, expectation)
    }

    func testExtendAndExport() throws {
        let template = """
            #extend("base"):
                #export("title","Welcome")
                #export("body"):
                    hello there
                #endexport
            #endextend
            """
        let expectation = """
            extend("base"):
              export("body"):
                raw("\\n        hello there\\n    ")
              export("title"):
                expression[stringLiteral("Welcome")]
            """
        
        let v = try XCTUnwrap(parse(template).first)
        guard case .extend(let test) = v else { throw LeafError(.unknownError("nope")) }
        let output = test.print(depth: 0)
        XCTAssertEqual(output, expectation)
    }

    func testCustomTag() throws {
        let template = """
            #custom(tag, foo == bar):
                some body
            #endcustom
            """

        let v = try XCTUnwrap(parse(template).first)
        guard case .custom(let test) = v else { throw LeafError(.unknownError("nope")) }

        let expectation = """
            custom(variable(tag), [foo == bar]):
              raw("\\n    some body\\n")
            """
        let output = test.print(depth: 0)
        XCTAssertEqual(output, expectation)
    }
}

### File: leaf-kit/Tests/LeafKitTests/GHTests/VaporLeaf.swift ###
/// Place all tests originating from https://github.com/vapor/leaf here.
/// Suffix test name with issue # (e.g., `testGH33()`)

@testable import LeafKit
import XCTest

final class GHLeafIssuesTest: XCTestCase {
    /// https://github.com/vapor/leaf/issues/96
    func testGH96() throws {
        let template = """
            #for(name in names):
                #(name): index=#(index) last=#(isLast) first=#(isFirst)
            #endfor
            """
        let expected = """

                tanner: index=0 last=false first=true

                ziz: index=1 last=false first=false

                vapor: index=2 last=true first=false

            """
        try XCTAssertEqual(render(template, ["names": ["tanner", "ziz", "vapor"]]), expected)
    }
    
    /// https://github.com/vapor/leaf/issues/99
    func testGH99() throws {
        let template = """
            Hi #(first) #(last)
            """
        let expected = """
            Hi Foo Bar
            """
        try XCTAssertEqual(render(template, ["first": "Foo", "last": "Bar"]), expected)
    }

    /// https://github.com/vapor/leaf/issues/101
    func testGH101() throws {
        let template = """
            #for(foo in foos):#(index+1):#(foo)#endfor
            """
        let expected = "1:A2:B3:C"
        try XCTAssertEqual(render(template, ["foos": ["A", "B", "C"]]), expected)
    }
    
    /// https://github.com/vapor/leaf/issues/105
    func testGH105() throws {
        let template1 = """
            #if(1 + 1 == 2):hi#endif
            """
        let expected1 = "hi"
        XCTAssertEqual(try render(template1, ["a": "a"]), expected1)

        let template2 = """
            #if(2 == 1 + 1):hi#endif
            """
        let expected2 = "hi"
        XCTAssertEqual(try render(template2, ["a": "a"]), expected2)

        let template3 = """
            #if(1 == 1 + 1 || 1 == 2 - 1):hi#endif
            """
        let expected3 = "hi"
        XCTAssertEqual(try render(template3, ["a": "a"]), expected3)
    }

    // https://github.com/vapor/leaf/issues/127
    func testGH127Inline() throws {
        let template = """
            <html>
            <head>
            <title></title>#comment: Translate all copy!!!!! #endcomment
            <style>
            """
        let expected = """
            <html>
            <head>
            <title></title>
            <style>
            """
        XCTAssertEqual(try render(template, ["a": "a"]), expected)
    }
}

### File: leaf-kit/Tests/LeafKitTests/GHTests/VaporLeafKit.swift ###
/// Place all tests originating from https://github.com/vapor/leaf-kit here.
/// Suffix test name with issue # (e.g., `testGH33()`).

@testable import LeafKit
import NIOConcurrencyHelpers
import XCTest

final class GHLeafKitIssuesTest: XCTestCase {
    /// https://github.com/vapor/leaf-kit/issues/33
    func testGH33() async throws {
        var test = TestFiles()
        test.files["/base.leaf"] = """
            <body>
                Directly extended snippet
                #extend("partials/picture.svg"):#endextend
                #import("body")
            </body>
            """
        test.files["/page.leaf"] = """
            #extend("base"):
                #export("body"):
                Snippet added through export/import
                #extend("partials/picture.svg"):#endextend
            #endexport
            #endextend
            """
        test.files["/partials/picture.svg"] = """
            <svg><path d="M0..."></svg>
            """

        let expected = """
            <body>
                Directly extended snippet
                <svg><path d="M0..."></svg>
                
                Snippet added through export/import
                <svg><path d="M0..."></svg>

            </body>
            """

        await XCTAssertEqualAsync(try await TestRenderer(sources: .singleSource(test)).render(path: "page").string, expected)
    }
    
    
    /// https://github.com/vapor/leaf-kit/issues/50
    func testGH50() async throws {
        var test = TestFiles()
        test.files["/a.leaf"] = """
            #extend("a/b"):
            #export("body"):#for(challenge in challenges):
            #extend("a/b-c-d"):#endextend#endfor
            #endexport
            #endextend
            """
        test.files["/a/b.leaf"] = """
            #import("body")
            """
        test.files["/a/b-c-d.leaf"] = """
            HI
            """

        let expected = """

            HI
            HI
            HI

            """

        await XCTAssertEqualAsync(try await TestRenderer(sources: .singleSource(test)).render(path: "a", context: ["challenges":["","",""]]).string, expected)
    }
    
    /// https://github.com/vapor/leaf-kit/issues/87
    func testGH87() {
        let template1 = """
            #if(2 % 2 == 0):hi#endif #if(0 == 4 % 2):there#endif
            """
        let expected1 = "hi there"
        XCTAssertEqual(try render(template1, ["a": "a"]), expected1)

        // test with double values
        let template2 = """
            #if(5.0 % 2.0 == 1.0):hi#endif #if(4.0 % 2.0 == 0.0):there#endif
            """
        let expected2 = "hi there"
        XCTAssertEqual(try render(template2, ["a": "a"]), expected2)
    }
    
    /// https://github.com/vapor/leaf-kit/issues/84
    func testGH84() async throws {
        var test = TestFiles()
        test.files["/base.leaf"] = """
            <body>
                Unfound import test:#import("body")
            </body>
            """
            test.files["/page.leaf"] = """
            #extend("base"):
            #endextend
            """

        let expected = """
            <body>
                Unfound import test:
            </body>
            """

        // Page renders as expected. Unresolved import is ignored.
        await XCTAssertEqualAsync(try await TestRenderer(sources: .singleSource(test)).render(path: "page").string, expected)

        // Page rendering throws expected error
        let config = LeafConfiguration(rootDirectory: "/", tagIndicator: LeafConfiguration.tagIndicator, ignoreUnfoundImports: false)

        await XCTAssertThrowsErrorAsync(try await TestRenderer(configuration: config, sources: .singleSource(test)).render(path: "page")) {
            switch ($0 as? LeafError)?.reason {
            case .unknownError(let s):
                XCTAssertEqual(s, "import(\"body\") should have been resolved BEFORE serialization")
            default:
                XCTFail("Expected '.unknown_error(import(\"body\") should have been resolved BEFORE serialization', got \($0.localizedDescription)")
            }
        }
    }
}

### File: leaf-kit/Tests/LeafKitTests/Templates/test.leaf ###
Leaf Template

### File: leaf-kit/Tests/LeafKitTests/Templates/SubTemplates/test.leaf ###
Leaf Template

